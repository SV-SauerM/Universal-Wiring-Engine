<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="UWE - Universal Wiring Engine: Professionelles Tool zur Erfassung und Dokumentation von Kabelb√§umen mit Ma√üstab-Messung und Wustec-Export">
    <meta name="keywords" content="Kabelbaum, Verdrahtung, Kabel, UWE, Wiring, Dokumentation">
    <meta name="author" content="UWE">
    <title>UWE - Universal Wiring Engine</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        
        :root { 
            --primary: #6366f1; 
            --primary-dark: #4f46e5; 
            --secondary: #1e293b; 
            --secondary-light: #334155;
            --success: #10b981; 
            --danger: #ef4444; 
            --warning: #f59e0b; 
            --light: #f8fafc; 
            --card-bg: rgba(255,255,255,0.05);
            --card-border: rgba(255,255,255,0.1);
        }
        
        * { box-sizing: border-box; }
        
        body { 
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; 
            display: flex; 
            height: 100vh; 
            margin: 0; 
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
            color: white; 
            overflow: hidden;
            position: relative;
        }
        
        /* Hilfe-Button oben rechts */
        #helpButton {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            color: white;
            border: none;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(99, 102, 241, 0.4);
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #helpButton:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(99, 102, 241, 0.6);
        }
        #helpButton:active {
            transform: scale(0.95);
        }
        
        /* Sidebar Design - Modern mit Glassmorphism */
        #sidebar { 
            width: 380px; 
            padding: 24px; 
            background: rgba(30, 41, 59, 0.8);
            backdrop-filter: blur(10px);
            border-right: 1px solid rgba(255,255,255,0.1); 
            overflow-y: auto; 
            flex-shrink: 0; 
            display: flex; 
            flex-direction: column; 
            gap: 20px;
            box-shadow: 4px 0 24px rgba(0,0,0,0.3);
        }
        
        /* Rechte Sidebar f√ºr Muster */
        #patternSidebar { 
            width: 350px; 
            padding: 24px; 
            background: rgba(30, 41, 59, 0.8);
            backdrop-filter: blur(10px);
            border-left: 1px solid rgba(255,255,255,0.1); 
            overflow-y: auto; 
            flex-shrink: 0; 
            display: flex; 
            flex-direction: column; 
            gap: 20px;
            box-shadow: -4px 0 24px rgba(0,0,0,0.3);
        }
        
        #sidebar::-webkit-scrollbar { width: 8px; }
        #sidebar::-webkit-scrollbar-track { background: rgba(255,255,255,0.05); border-radius: 4px; }
        #sidebar::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 4px; }
        #sidebar::-webkit-scrollbar-thumb:hover { background: rgba(255,255,255,0.3); }
        
        /* Titel Branding - Modern */
        .brand-container { 
            margin-bottom: 8px; 
            padding-bottom: 16px; 
            border-bottom: 2px solid rgba(99, 102, 241, 0.3); 
        }
        .brand-letter { 
            font-size: 2em; 
            font-weight: 700; 
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            display: inline-block;
            letter-spacing: -0.5px;
        }
        .brand-suffix { 
            font-size: 0.95em; 
            color: #94a3b8; 
            font-weight: 500; 
            margin-right: 12px; 
        }

        /* Step Cards - Modern Card Design */
        .step { 
            background: rgba(255,255,255,0.05);
            backdrop-filter: blur(10px);
            padding: 20px; 
            border-radius: 12px; 
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
        }
        .step:hover {
            background: rgba(255,255,255,0.08);
            border-color: rgba(99, 102, 241, 0.3);
            transform: translateY(-2px);
            box-shadow: 0 8px 16px rgba(0,0,0,0.2);
        }
        .step strong {
            display: block;
            font-size: 0.95em;
            font-weight: 600;
            color: #e2e8f0;
            margin-bottom: 12px;
            letter-spacing: 0.3px;
        }
        
        #main { 
            flex-grow: 1; 
            background: linear-gradient(135deg, #f1f5f9 0%, #e2e8f0 100%); 
            display: flex; 
            justify-content: center; 
            align-items: center;
            position: relative; 
            overflow: auto; 
            position: relative; 
        }
        canvas { 
            background: white; 
            cursor: crosshair; 
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            border-radius: 8px;
            max-width: 100%; 
            max-height: 95vh; 
            object-fit: contain; 
        }

        /* Modal - Modern Design */
        #overlay { 
            display: none; 
            position: fixed; 
            top:0; 
            left:0; 
            width:100%; 
            height:100%; 
            background: rgba(15, 23, 42, 0.8);
            backdrop-filter: blur(4px);
            z-index: 999; 
        }
        #modal { 
            display: none; 
            position: fixed; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%); 
            width: 90%; 
            max-width: 1100px; 
            background: white; 
            color: #333; 
            padding: 32px; 
            border-radius: 16px; 
            box-shadow: 0 25px 50px rgba(0,0,0,0.5); 
            z-index: 1000; 
            max-height: 90vh; 
            overflow-y: auto;
            border: 1px solid rgba(0,0,0,0.1);
        }
        #modal::-webkit-scrollbar { width: 10px; }
        #modal::-webkit-scrollbar-track { background: #f1f5f9; border-radius: 5px; }
        #modal::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 5px; }
        #modal::-webkit-scrollbar-thumb:hover { background: #94a3b8; }
        
        table { 
            width: 100%; 
            border-collapse: collapse; 
            margin-top: 20px; 
            background: white; 
            border-radius: 8px;
            overflow: hidden;
        }
        th, td { 
            border: 1px solid #e2e8f0; 
            padding: 12px; 
            text-align: left; 
            font-size: 14px; 
            color: #334155; 
        }
        th { 
            background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
            font-weight: 600;
            color: #1e293b;
        }
        tr:hover { background: #f8fafc; }
        
        input[type="text"], input[type="number"], select { 
            width: 100%; 
            padding: 10px 12px; 
            box-sizing: border-box; 
            border: 2px solid #e2e8f0; 
            border-radius: 8px; 
            font-size: 14px;
            font-family: 'Inter', sans-serif;
            transition: all 0.2s ease;
            background: white;
        }
        input[type="text"]:focus, input[type="number"]:focus, select:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
        }
        input[type="color"] {
            height: 44px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        input[type="color"]:hover {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
        }
        input[type="file"] {
            padding: 10px;
            border: 2px dashed #cbd5e1;
            border-radius: 8px;
            background: rgba(255,255,255,0.05);
            color: white;
            cursor: pointer;
            transition: all 0.2s ease;
            width: 100%;
        }
        input[type="file"]:hover {
            border-color: var(--primary);
            background: rgba(99, 102, 241, 0.1);
        }
        input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: var(--primary);
        }
        
        /* Buttons - Modern Design */
        .fill-btn { 
            background: var(--primary); 
            color: white; 
            border: none; 
            border-radius: 6px; 
            padding: 4px 10px; 
            font-size: 11px; 
            cursor: pointer; 
            float: right; 
            margin-top: 2px;
            font-weight: 500;
            transition: all 0.2s ease;
        }
        .fill-btn:hover {
            background: var(--primary-dark);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(99, 102, 241, 0.3);
        }
        
        button { 
            padding: 12px 20px; 
            border-radius: 8px; 
            border: none; 
            font-weight: 600; 
            cursor: pointer; 
            transition: all 0.2s ease;
            font-family: 'Inter', sans-serif;
            font-size: 14px;
            letter-spacing: 0.3px;
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 16px rgba(0,0,0,0.2);
        }
        button:active {
            transform: translateY(0);
        }
        .btn-primary { 
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            color: white; 
            width: 100%;
            box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);
        }
        .btn-primary:hover {
            box-shadow: 0 8px 20px rgba(99, 102, 241, 0.4);
        }
        .btn-success { 
            background: linear-gradient(135deg, var(--success) 0%, #059669 100%);
            color: white; 
            width: 100%;
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
        }
        .btn-success:hover {
            box-shadow: 0 8px 20px rgba(16, 185, 129, 0.4);
        }
        .btn-danger { 
            background: linear-gradient(135deg, var(--danger) 0%, #dc2626 100%);
            color: white; 
            width: 100%;
            box-shadow: 0 4px 12px rgba(239, 68, 68, 0.3);
        }
        
        /* Liste in Sidebar - Modern Cards */
        .bundle-item { 
            background: rgba(255,255,255,0.08);
            backdrop-filter: blur(10px);
            padding: 14px; 
            border-radius: 10px; 
            margin-top: 8px; 
            display: flex; 
            align-items: center; 
            justify-content: space-between; 
            font-size: 0.9em;
            border: 1px solid rgba(255,255,255,0.1);
            transition: all 0.2s ease;
        }
        .bundle-item:hover {
            background: rgba(255,255,255,0.12);
            border-color: rgba(99, 102, 241, 0.3);
            transform: translateX(4px);
        }
        .bundle-info { 
            display: flex; 
            align-items: center; 
            gap: 12px; 
        }
        .bundle-actions { 
            display: flex; 
            align-items: center; 
            gap: 6px; 
        }
        .action-btn { 
            padding: 6px; 
            font-size: 14px; 
            background: rgba(255,255,255,0.1);
            color: white; 
            border-radius: 6px; 
            cursor: pointer; 
            width: 32px; 
            height: 32px; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            border: 1px solid rgba(255,255,255,0.1);
            transition: all 0.2s ease;
        }
        .action-btn:hover {
            background: rgba(255,255,255,0.2);
            transform: scale(1.1);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        .color-dot { 
            width: 14px; 
            height: 14px; 
            border-radius: 50%; 
            border: 2px solid rgba(255,255,255,0.3);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .color-dot:hover {
            transform: scale(1.2);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        
        /* Special Step Styling */
        .step[style*="background: #27ae60"] {
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.2) 0%, rgba(5, 150, 105, 0.2) 100%);
            border: 1px solid rgba(16, 185, 129, 0.3);
        }
        .step[style*="background: #27ae60"] button {
            background: white;
            color: var(--success);
            font-weight: 600;
        }
        .step[style*="background: #27ae60"] button:hover {
            background: var(--success);
            color: white;
        }
        
        /* Label Styling */
        label {
            font-weight: 500;
            color: #cbd5e1;
            font-size: 0.9em;
            margin-bottom: 6px;
            display: block;
        }
        
        /* Hint Text */
        #drawHint {
            color: #94a3b8;
            font-size: 0.85em;
        }
        
        /* Project List Header */
        #project-list strong {
            font-size: 1em;
            font-weight: 600;
            color: #e2e8f0;
            letter-spacing: 0.3px;
        }
    </style>
</head>
<body>

<!-- Hilfe-Button oben rechts -->
<button id="helpButton" onclick="openHelpWindow()" title="Anleitung √∂ffnen">?</button>

<div id="sidebar">
    <div class="brand-container">
        <span class="brand-letter">U</span><span class="brand-suffix">niversal</span>
        <span class="brand-letter">W</span><span class="brand-suffix">iring</span>
        <span class="brand-letter">E</span><span class="brand-suffix">ngine</span>
    </div>
    
    <div class="step" style="background: #27ae60; border-left-color: white;">
        <strong>Projekt-Speicher</strong>
        <div style="display:flex; gap:5px; margin-top:5px;">
            <button onclick="saveProjectJSON()" style="background: white; color: #27ae60; flex:1; padding:8px;">Speichern</button>
            <button onclick="document.getElementById('loadProject').click()" style="background: white; color: #27ae60; flex:1; padding:8px;">Laden</button>
        </div>
        <input type="file" id="loadProject" style="display:none" accept=".json" onchange="loadProjectJSON(event)">
    </div>

    <div class="step">
        <strong>1. Bild laden</strong>
        <input type="file" id="upload" accept="image/*">
        <label style="display:flex; align-items:center; gap:5px; margin-top:10px; font-size:0.9em; cursor:pointer;">
            <input type="checkbox" id="autoFitCheckbox" checked onchange="toggleAutoFit()">
            <span>Bild automatisch an Fenster anpassen</span>
        </label>
    </div>

    <div class="step">
        <strong>2. Ma√üstab</strong>
        <div style="font-size: 0.85em; color: #bdc3c7; margin-bottom: 5px;">(Eingabe in mm)</div>
        <input type="number" id="realLength" placeholder="L√§nge in mm" value="0">
        <button class="btn-primary" onclick="setMode('scale')" id="btnScale">Ma√üstab festlegen</button>
        <button class="btn-success" id="btnConfirmScale" onclick="confirmScale()" style="display:none; margin-top:10px;">Ma√üstab best√§tigen ‚úì</button>
    </div>

    <div class="step">
        <strong>3. Farbe & Messen</strong>
        <input type="color" id="drawColor" value="#f39c12" style="height: 40px; width: 100%; cursor: pointer; border:none; border-radius:4px;">
        <button class="btn-primary" onclick="setMode('measure')" id="btnMeasure" disabled style="background: var(--warning); margin-top:10px;">Kabelstrang zeichnen</button>
        <div id="drawHint" style="display:none; font-size: 0.8em; color: #bdc3c7; margin-top: 5px; font-style: italic;">üí° Tipp: Doppelklick beendet das Zeichnen</div>
    </div>

    <div id="project-list">
        <strong>Erfasste Str√§nge:</strong>
        <div id="bundleContainer" style="margin-top:10px;"></div>
    </div>

    <button class="btn-success" onclick="exportWustec()">Wustec Export (.csv)</button>
    <button class="btn-primary" onclick="exportVisual()" style="background: #8e44ad;">Bild & Legende Export</button>
</div>

<div id="main"><canvas id="canvas"></canvas></div>

<!-- Rechte Sidebar f√ºr Muster-Kabelstr√§nge -->
<div id="patternSidebar">
    <div class="brand-container">
        <div class="brand-letter">M</div>
        <div class="brand-text">
            <div class="brand-title">Muster</div>
            <div class="brand-subtitle">Kabelstr√§nge</div>
        </div>
    </div>
    
    <div class="step">
        <div style="display: flex; align-items: center; justify-content: space-between; cursor: pointer; user-select: none; padding: 5px 0;" onclick="togglePatternManagement()">
            <h3 style="margin: 0;">Muster-Verwaltung</h3>
            <span id="patternManagementToggle" style="font-size: 1.2em; transition: transform 0.2s;">‚ñº</span>
        </div>
        <div id="patternManagementContent" style="margin-top: 15px;">
            <button class="btn-primary" onclick="openPatternModal()" style="margin-bottom: 10px;">+ Neues Muster</button>
            <button class="btn-primary" onclick="createPatternGroup()" style="margin-bottom: 10px; background: var(--secondary-light);">+ Neue Gruppe</button>
            <button class="btn-danger" onclick="deletePatternGroupFromList()" style="margin-bottom: 10px;">Gruppe l√∂schen</button>
            <button class="btn-success" onclick="exportPatterns()" style="margin-bottom: 10px;">Muster exportieren</button>
            <input type="file" id="importPatterns" accept=".json" onchange="importPatterns(event)" style="margin-bottom: 10px;">
            <label for="importPatterns" style="display: block; text-align: center; padding: 8px; background: var(--card-bg); border-radius: 6px; cursor: pointer; border: 1px solid var(--card-border);">
                üì• Muster importieren
            </label>
        </div>
    </div>
    
    <div class="step">
        <h3 style="margin-top: 0;" id="patternListTitle">Muster-Liste</h3>
        <div id="patternContainer" style="max-height: 500px; overflow-y: auto;">
            <!-- Muster werden hier dynamisch eingef√ºgt -->
        </div>
    </div>
</div>

<div id="overlay" onclick="closeModal()"></div>
<div id="modal">
    <div style="display:flex; justify-content:space-between; align-items:center; border-bottom:2px solid #eee; margin-bottom:15px;">
        <h3 id="modalHeaderTitle" style="margin:0">Kabelbaum Details</h3>
        <span id="currentLengthDisplay" style="font-weight:bold; color:var(--success); font-size:1.2em;"></span>
    </div>
    <div style="display:grid; grid-template-columns: 1fr 1fr 1fr; gap:15px; margin-bottom:15px;">
        <div><label>Strang Name:</label><input type="text" id="bundleName"></div>
        <div><label>Zuschlag Vorn (mm):</label><input type="number" id="plusStart" value="150"></div>
        <div><label>Zuschlag Hinten (mm):</label><input type="number" id="plusEnd" value="150"></div>
    </div>
    <div id="patternGroupSelector" style="display:none; margin-bottom:15px;">
        <label>Gruppe:</label>
        <select id="patternGroupSelect" style="width:100%; padding:8px; border-radius:6px; background:var(--input-bg); color:var(--text-light); border:1px solid var(--card-border);">
            <!-- Wird dynamisch gef√ºllt -->
        </select>
    </div>
    <div style="background:#f8f9fa; padding:10px; border-radius:5px; margin-bottom:10px; display:flex; gap:10px; align-items:center;">
        <label>Adern:</label>
        <input type="number" id="wireCount" value="1" min="1" style="width:70px;">
        <button onclick="updateWireTable()" style="padding:6px 12px; background:var(--secondary); color:white;">Tabelle erzeugen</button>
    </div>
    <table id="wireTable">
        <thead>
            <tr>
                <th style="width:40px;">#</th>
                <th>Typ <button class="fill-btn" onclick="autoFill('wire-type', false)">‚ñº</button></th>
                <th>Farbe <button class="fill-btn" onclick="autoFill('wire-color', false)">‚ñº</button></th>
                <th>mm¬≤ <button class="fill-btn" onclick="autoFill('wire-cross', false)">‚ñº</button></th>
                <th>Quelle <button class="fill-btn" onclick="autoFill('wire-label-s', true)">‚ñº+</button></th>
                <th>Ziel <button class="fill-btn" onclick="autoFill('wire-label-e', true)">‚ñº+</button></th>
            </tr>
        </thead>
        <tbody></tbody>
    </table>
    <div style="margin-top:20px; display:flex; justify-content:flex-end; gap:10px;">
        <button onclick="closeModal()">Abbrechen</button>
        <button class="btn-success" onclick="saveCableBundle()" style="width:220px;">Speichern</button>
    </div>
</div>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let img = new Image(), mode = 'none', mmPerPixel = 0, currentPath = [], snapshot, allBundles = [], lastMeasuredLength = 0, mouseX = 0, mouseY = 0;
    let originalImageSnapshot = null, editIndex = -1;
    let zoom = 1, panX = 0, panY = 0, isPanning = false, lastPanPoint = { x: 0, y: 0 };
    let patternBundles = []; // Array f√ºr Muster-Kabelstr√§nge
    let selectedPatternIndex = -1; // Index des ausgew√§hlten Musters
    let isPatternMode = false; // Ob ein Muster ausgew√§hlt wurde
    let patternListName = ''; // Name der Muster-Liste (Dateiname)
    let patternGroups = []; // Array f√ºr Muster-Gruppen [{id: string, name: string, collapsed: boolean}]
    let collapsedGroups = {}; // Objekte f√ºr auf-/zuklappbare Gruppen {groupId: boolean}
    let patternManagementCollapsed = false; // Ob die Muster-Verwaltung zugeklappt ist
    let autoFitToWindow = true; // Automatische Bildskalierung auf Fenstergr√∂√üe
    let imageScale = 1, imageOffsetX = 0, imageOffsetY = 0; // F√ºr Bild-Skalierung

    document.getElementById('upload').onchange = (e) => loadMainImage(e.target.files[0]);

    function resizeCanvas() {
        const main = document.getElementById('main');
        canvas.width = main.clientWidth;
        canvas.height = main.clientHeight;
        if (img.complete && img.width > 0 && autoFitToWindow) {
            calculateImageScale();
            rebuildDrawing();
        }
    }
    
    function calculateImageScale() {
        if (!img.complete || img.width === 0) return;
        const main = document.getElementById('main');
        const availableWidth = main.clientWidth;
        const availableHeight = main.clientHeight;
        
        // Berechne Skalierung, damit das Bild vollst√§ndig sichtbar ist
        const scaleX = availableWidth / img.width;
        const scaleY = availableHeight / img.height;
        imageScale = Math.min(scaleX, scaleY) * 0.95; // 95% f√ºr etwas Rand
        
        // Zentriere das Bild - in Canvas-Koordinaten
        const scaledWidth = img.width * imageScale;
        const scaledHeight = img.height * imageScale;
        imageOffsetX = (availableWidth - scaledWidth) / 2;
        imageOffsetY = (availableHeight - scaledHeight) / 2;
    }
    
    function toggleAutoFit() {
        autoFitToWindow = document.getElementById('autoFitCheckbox').checked;
        if (img.complete && img.width > 0) {
            if (autoFitToWindow) {
                resizeCanvas();
            } else {
                // Zur√ºck zur Original-Bildgr√∂√üe
                canvas.width = img.width;
                canvas.height = img.height;
                imageScale = 1;
                imageOffsetX = 0;
                imageOffsetY = 0;
                zoom = 1;
                panX = 0;
                panY = 0;
                rebuildDrawing();
            }
        }
    }

    function loadMainImage(file) {
        if (!file) return;
        const reader = new FileReader();
        reader.onerror = () => alert("Fehler beim Laden des Bildes!");
        reader.onload = (f) => {
            img.onload = () => {
                if (autoFitToWindow) {
                    resizeCanvas();
                } else {
                    canvas.width = img.width; 
                    canvas.height = img.height;
                    imageScale = 1;
                    imageOffsetX = 0;
                    imageOffsetY = 0;
                }
                // Reset Zoom und Pan beim Laden eines neuen Bildes
                zoom = 1;
                panX = 0;
                panY = 0;
                originalImageSnapshot = ctx.getImageData(0,0,canvas.width, canvas.height);
                rebuildDrawing();
            };
            img.onerror = () => alert("Fehler: Bild konnte nicht geladen werden!");
            img.src = f.target.result;
        };
        reader.readAsDataURL(file);
    }

    // Canvas-Gr√∂√üe bei Fenster-Resize anpassen (nur wenn autoFitToWindow aktiv)
    window.addEventListener('resize', () => {
        if (img.complete && img.width > 0 && autoFitToWindow) {
            resizeCanvas();
        }
    });

    function setMode(m) { 
        mode = m; 
        currentPath = []; 
        // Muster-Modus zur√ºcksetzen, wenn normaler Zeichnen-Modus gestartet wird
        if (m === 'measure' && !isPatternMode) {
            isPatternMode = false;
            selectedPatternIndex = -1;
        }
        if(m === 'measure' && editIndex === -1 && !isPatternMode) {
            document.getElementById('btnMeasure').style.background = 'var(--warning)';
            document.getElementById('btnMeasure').textContent = 'Kabelstrang zeichnen';
            document.getElementById('drawHint').style.display = 'block';
        } else {
            document.getElementById('drawHint').style.display = 'none';
        }
        // Snapshot aktualisieren, damit Zeichnen funktioniert
        rebuildDrawing();
    }
    function getPos(e) {
        const rect = canvas.getBoundingClientRect();
        // WICHTIG: Umrechnung von Anzeige-Koordinaten zu Canvas-Pixel-Koordinaten
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        
        const canvasX = (e.clientX - rect.left) * scaleX;
        const canvasY = (e.clientY - rect.top) * scaleY;
        
        // Verwende die Canvas-Transformationsmatrix direkt f√ºr pr√§zise Umkehrung
        ctx.save();
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.translate(panX * zoom, panY * zoom);
        ctx.scale(zoom, zoom);
        if (autoFitToWindow) {
            ctx.translate(imageOffsetX / zoom, imageOffsetY / zoom);
            ctx.scale(imageScale, imageScale);
        }
        
        // Hole die Transformationsmatrix
        const matrix = ctx.getTransform();
        ctx.restore();
        
        // Berechne die inverse Transformation
        const det = matrix.a * matrix.d - matrix.b * matrix.c;
        if (Math.abs(det) < 0.0001) {
            // Fallback: direkte Berechnung
            if (autoFitToWindow) {
                return {
                    x: (canvasX - imageOffsetX - panX * zoom) / (imageScale * zoom),
                    y: (canvasY - imageOffsetY - panY * zoom) / (imageScale * zoom)
                };
            } else {
                return {
                    x: canvasX / zoom - panX,
                    y: canvasY / zoom - panY
                };
            }
        }
        
        // Inverse Transformation mit Matrix
        const x = (matrix.d * (canvasX - matrix.e) - matrix.c * (canvasY - matrix.f)) / det;
        const y = (matrix.a * (canvasY - matrix.f) - matrix.b * (canvasX - matrix.e)) / det;
        
        return { x, y };
    }

    canvas.onmousemove = (e) => {
        if (isPanning) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const deltaX = ((e.clientX - rect.left) - lastPanPoint.x) * scaleX;
            const deltaY = ((e.clientY - rect.top) - lastPanPoint.y) * scaleY;
            panX += deltaX / zoom;
            panY += deltaY / zoom;
            lastPanPoint = { x: e.clientX - rect.left, y: e.clientY - rect.top };
            rebuildDrawing();
            return;
        }
        const pos = getPos(e); mouseX = pos.x; mouseY = pos.y;
        if (mode !== 'none' && currentPath.length > 0) redrawCanvas();
    };

    function redrawCanvas() {
        ctx.save();
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.restore();
        
        ctx.save();
        // Transformationen
        ctx.translate(panX * zoom, panY * zoom);
        ctx.scale(zoom, zoom);
        
        if (autoFitToWindow) {
            // Mit Bildskalierung
            ctx.translate(imageOffsetX / zoom, imageOffsetY / zoom);
            ctx.scale(imageScale, imageScale);
        }
        
        // Zeichne das Basisbild
        if(img.complete && img.width > 0) {
            ctx.drawImage(img, 0, 0);
        }
        
        // Zeichne alle Str√§nge (in Bild-Koordinaten)
        allBundles.forEach(b => {
            if (!b.path || b.path.length === 0) return;
            ctx.strokeStyle = b.color;
            const lineWidth = autoFitToWindow ? 
                Math.max(4, canvas.width / 500) / (zoom * imageScale) : 
                Math.max(4, canvas.width / 500) / zoom;
            ctx.lineWidth = lineWidth;
            ctx.beginPath();
            ctx.moveTo(b.path[0].x, b.path[0].y);
            b.path.forEach(p => ctx.lineTo(p.x, p.y));
            ctx.stroke();
        });
        
        // Zeichne aktuellen Pfad (in Bild-Koordinaten)
        const lineWidth = autoFitToWindow ? 
            Math.max(4, canvas.width / 500) / (zoom * imageScale) : 
            Math.max(4, canvas.width / 500) / zoom;
        ctx.lineWidth = lineWidth;
        ctx.strokeStyle = (mode === 'scale') ? 'red' : document.getElementById('drawColor').value;
        if (currentPath.length > 0) {
            ctx.beginPath(); 
            ctx.moveTo(currentPath[0].x, currentPath[0].y);
            currentPath.forEach(p => ctx.lineTo(p.x, p.y));
            ctx.lineTo(mouseX, mouseY); 
            ctx.stroke();
        }
        ctx.restore();
    }

    canvas.onclick = (e) => {
        if (e.button === 1) return; // Ignoriere mittlere Maustaste
        if (mode === 'none') return;
        currentPath.push(getPos(e));
        // Aktualisiere nur den Snapshot, ohne alles neu zu zeichnen
        // Das verhindert, dass die Zeichnung springt
        updateSnapshot();
        if (mode === 'scale' && currentPath.length === 2) {
            document.getElementById('btnConfirmScale').style.display = 'block';
            mode = 'none';
        }
    };
    
    function updateSnapshot() {
        // Zeichne alles neu, um einen aktuellen Snapshot zu erstellen
        ctx.save();
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.restore();
        
        ctx.save();
        // Transformationen
        ctx.translate(panX * zoom, panY * zoom);
        ctx.scale(zoom, zoom);
        
        if (autoFitToWindow) {
            ctx.translate(imageOffsetX / zoom, imageOffsetY / zoom);
            ctx.scale(imageScale, imageScale);
        }
        
        // Zeichne das Basisbild
        if(img.complete && img.width > 0) {
            ctx.drawImage(img, 0, 0);
        }
        
        // Zeichne alle gespeicherten Str√§nge (in Bild-Koordinaten)
        allBundles.forEach(b => {
            if (!b.path || b.path.length === 0) return;
            ctx.strokeStyle = b.color;
            const lineWidth = autoFitToWindow ? 
                Math.max(4, canvas.width / 500) / (zoom * imageScale) : 
                Math.max(4, canvas.width / 500) / zoom;
            ctx.lineWidth = lineWidth;
            ctx.beginPath();
            ctx.moveTo(b.path[0].x, b.path[0].y);
            b.path.forEach(p => ctx.lineTo(p.x, p.y));
            ctx.stroke();
        });
        
        // Zeichne bereits gesetzte Punkte des aktuellen Pfads (ohne Mauszeiger)
        if (currentPath.length > 0) {
            const lineWidth = autoFitToWindow ? 
                Math.max(4, canvas.width / 500) / (zoom * imageScale) : 
                Math.max(4, canvas.width / 500) / zoom;
            ctx.lineWidth = lineWidth;
            ctx.strokeStyle = (mode === 'scale') ? 'red' : document.getElementById('drawColor').value;
            ctx.beginPath();
            ctx.moveTo(currentPath[0].x, currentPath[0].y);
            for (let i = 1; i < currentPath.length; i++) {
                ctx.lineTo(currentPath[i].x, currentPath[i].y);
            }
            ctx.stroke();
        }
        ctx.restore();
        
        // Snapshot erstellen
        snapshot = ctx.getImageData(0,0,canvas.width, canvas.height);
    }
    
    // Mausrad-Zoom
    canvas.onwheel = (e) => {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        const mouseCanvasX = (e.clientX - rect.left) * scaleX;
        const mouseCanvasY = (e.clientY - rect.top) * scaleY;
        
        const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
        const newZoom = Math.max(0.1, Math.min(5, zoom * zoomFactor));
        
        // Berechne den Punkt unter dem Mauszeiger in Bild-Koordinaten (vor dem Zoom)
        let imagePointX, imagePointY;
        if (autoFitToWindow) {
            imagePointX = (mouseCanvasX - imageOffsetX - panX * zoom) / (imageScale * zoom);
            imagePointY = (mouseCanvasY - imageOffsetY - panY * zoom) / (imageScale * zoom);
        } else {
            imagePointX = mouseCanvasX / zoom - panX;
            imagePointY = mouseCanvasY / zoom - panY;
        }
        
        // Setze den Zoom
        zoom = newZoom;
        
        // Berechne panX und panY neu, damit der gleiche Bildpunkt unter dem Mauszeiger bleibt
        if (autoFitToWindow) {
            // Mit Bildskalierung: Stelle sicher, dass imagePointX/Y unter mouseCanvasX/Y bleibt
            panX = (mouseCanvasX - imageOffsetX - imagePointX * imageScale * zoom) / zoom;
            panY = (mouseCanvasY - imageOffsetY - imagePointY * imageScale * zoom) / zoom;
        } else {
            // Ohne Bildskalierung
            panX = mouseCanvasX / zoom - imagePointX;
            panY = mouseCanvasY / zoom - imagePointY;
        }
        
        rebuildDrawing();
    };
    
    // Mittlere Maustaste f√ºr Panning
    canvas.onmousedown = (e) => {
        if (e.button === 1) { // Mittlere Maustaste
            e.preventDefault();
            isPanning = true;
            const rect = canvas.getBoundingClientRect();
            lastPanPoint = { x: e.clientX - rect.left, y: e.clientY - rect.top };
            canvas.style.cursor = 'grabbing';
        }
    };
    
    canvas.onmouseup = (e) => {
        if (e.button === 1) {
            isPanning = false;
            canvas.style.cursor = 'crosshair';
        }
    };
    
    canvas.onmouseleave = () => {
        isPanning = false;
        canvas.style.cursor = 'crosshair';
    };
    
    // Verhindere Standard-Scroll-Verhalten bei mittlerer Maustaste
    canvas.oncontextmenu = (e) => {
        if (e.button === 1) e.preventDefault();
    };

    function confirmScale() {
        if (currentPath.length < 2) {
            alert("Bitte zuerst zwei Punkte f√ºr den Ma√üstab setzen!");
            return;
        }
        const realLength = parseFloat(document.getElementById('realLength').value);
        if (!realLength || realLength <= 0) {
            alert("Bitte eine g√ºltige L√§nge in mm eingeben!");
            return;
        }
        const d = Math.sqrt(Math.pow(currentPath[1].x-currentPath[0].x,2)+Math.pow(currentPath[1].y-currentPath[0].y,2));
        if (d === 0) {
            alert("Die beiden Punkte sind identisch! Bitte zwei verschiedene Punkte w√§hlen.");
            return;
        }
        mmPerPixel = realLength / d;
        document.getElementById('btnMeasure').disabled = false;
        document.getElementById('btnConfirmScale').style.display = 'none';
        rebuildDrawing();
    }

    function rebuildDrawing() {
        if(!img.complete || img.width === 0) return;
        ctx.save();
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.restore();
        
        ctx.save();
        // Transformationen (gleiche wie in redrawCanvas)
        ctx.translate(panX * zoom, panY * zoom);
        ctx.scale(zoom, zoom);
        
        if (autoFitToWindow) {
            ctx.translate(imageOffsetX / zoom, imageOffsetY / zoom);
            ctx.scale(imageScale, imageScale);
        }
        
        // Bild zeichnen
        ctx.drawImage(img, 0, 0);
        
        // Str√§nge zeichnen (in Bild-Koordinaten)
        allBundles.forEach(b => {
            if (!b.path || b.path.length === 0) return;
            ctx.strokeStyle = b.color;
            const lineWidth = autoFitToWindow ? 
                Math.max(4, canvas.width / 500) / (zoom * imageScale) : 
                Math.max(4, canvas.width / 500) / zoom;
            ctx.lineWidth = lineWidth;
            ctx.beginPath();
            ctx.moveTo(b.path[0].x, b.path[0].y);
            b.path.forEach(p => ctx.lineTo(p.x, p.y));
            ctx.stroke();
        });
        ctx.restore();
        
        // Snapshot ohne Transformation f√ºr aktuellen Pfad
        snapshot = ctx.getImageData(0,0,canvas.width, canvas.height);
    }

    canvas.ondblclick = () => {
        if (mode === 'measure' && currentPath.length > 1) {
            let px = 0;
            for(let i=1; i<currentPath.length; i++) px += Math.sqrt(Math.pow(currentPath[i].x-currentPath[i-1].x,2)+Math.pow(currentPath[i].y-currentPath[i-1].y,2));
            lastMeasuredLength = px * mmPerPixel;
            
            // Wenn Muster-Modus aktiv, √∂ffne Modal mit bereits geladenen Muster-Daten
            if (isPatternMode && selectedPatternIndex >= 0) {
                // Daten sind bereits geladen, √∂ffne nur das Modal
                document.getElementById('modal').style.display = 'block';
                document.getElementById('overlay').style.display = 'block';
            } else if(editIndex === -1) {
                openModal();
            } else {
                // Neuzeichnen-Modus: Modal mit bestehenden Daten √∂ffnen
            openModal();
            }
        }
    };

    function openModal() {
        document.getElementById('modal').style.display = 'block';
        document.getElementById('overlay').style.display = 'block';
        
        // Verstecke Gruppenauswahl f√ºr normale Kabelstr√§nge
        if (!isPatternMode) {
            document.getElementById('patternGroupSelector').style.display = 'none';
        }
        
        // Wenn Muster-Modus aktiv, √ºberschreibe die Daten NICHT (sie sind bereits in selectPattern() geladen)
        if (isPatternMode && selectedPatternIndex >= 0) {
            // Daten sind bereits geladen, nichts √ºberschreiben
            return;
        }
        
        if(editIndex === -1) {
            document.getElementById('bundleName').value = "X" + (allBundles.length + 1);
            updateWireTable();
        } else {
            const b = allBundles[editIndex];
            document.getElementById('bundleName').value = b.name;
            document.getElementById('plusStart').value = b.pS;
            document.getElementById('plusEnd').value = b.pE;
            document.getElementById('wireCount').value = b.wires.length;
            updateWireTable(b.wires);
        }
    }

    function closeModal() { 
        document.getElementById('modal').style.display = 'none'; 
        document.getElementById('overlay').style.display = 'none'; 
        if(editIndex !== -1 && mode === 'measure') {
            // Neuzeichnen-Modus bleibt aktiv
            snapshot = ctx.getImageData(0,0,canvas.width, canvas.height);
        } else {
            currentPath = []; 
            editIndex = -1;
            mode = 'none';
            document.getElementById('btnMeasure').style.background = 'var(--warning)';
            document.getElementById('btnMeasure').textContent = 'Kabelstrang zeichnen';
            document.getElementById('drawHint').style.display = 'none';
            rebuildDrawing();
        }
    }

    function updateWireTable(existingWires = null) {
        const count = parseInt(document.getElementById('wireCount').value);
        const tbody = document.querySelector("#wireTable tbody");
        tbody.innerHTML = "";
        for(let i=1; i<=count; i++) {
            const w = existingWires ? existingWires[i-1] : { t: 'H07V-K', c: 'bk', cr: '1.5', s: '', e: '' };
            tbody.innerHTML += `<tr><td>${i}</td>
                <td><input type="text" class="wire-type" value="${w.t}"></td>
                <td><select class="wire-color">
                    <option value="bk" ${w.c==='bk'?'selected':''}>Schwarz (bk)</option>
                    <option value="bl" ${w.c==='bl'?'selected':''}>Blau (bl)</option>
                    <option value="dbl" ${w.c==='dbl'?'selected':''}>Dunkelblau (dbl)</option>
                    <option value="dblws" ${w.c==='dblws'?'selected':''}>Dunkelblau-Wei√ü (dblws)</option>
                    <option value="br" ${w.c==='br'?'selected':''}>Braun (br)</option>
                    <option value="gnge" ${w.c==='gnge'?'selected':''}>Gr√ºn-Gelb (gnge)</option>
                    <option value="rt" ${w.c==='rt'?'selected':''}>Rot (rt)</option>
                    <option value="gr" ${w.c==='gr'?'selected':''}>Grau (gr)</option>
                    <option value="or" ${w.c==='or'?'selected':''}>Orange (or)</option>
                    <option value="ws" ${w.c==='ws'?'selected':''}>Wei√ü (ws)</option>
                </select></td>
                <td><input type="text" class="wire-cross" value="${w.cr}"></td>
                <td><input type="text" class="wire-label-s" value="${w.s}" placeholder="z.B. F1"></td>
                <td><input type="text" class="wire-label-e" value="${w.e}" placeholder="z.B. X1.1"></td></tr>`;
        }
    }

    function saveCableBundle() {
        const bundleName = document.getElementById('bundleName').value.trim();
        if (!bundleName) {
            alert("Bitte einen Strang-Namen eingeben!");
            return;
        }
        // Pfad nur pr√ºfen, wenn nicht im Muster-Modus (Muster k√∂nnen ohne Pfad gespeichert werden)
        if (!isPatternMode && editIndex === -1 && currentPath.length < 2) {
            alert("Bitte zuerst einen Pfad zeichnen!");
            return;
        }
        const pathToUse = currentPath.length > 0 ? [...currentPath] : (editIndex === -1 ? [] : allBundles[editIndex].path);
        // Pfad-Validierung nur f√ºr normale Kabelstr√§nge (nicht f√ºr Muster)
        if (!isPatternMode && pathToUse.length < 2) {
            alert("Der Pfad muss mindestens 2 Punkte haben!");
            return;
        }
        const b = { 
            name: bundleName, 
            color: editIndex === -1 ? document.getElementById('drawColor').value : allBundles[editIndex].color,
            len: lastMeasuredLength, 
            pS: parseFloat(document.getElementById('plusStart').value) || 0, 
            pE: parseFloat(document.getElementById('plusEnd').value) || 0, 
            path: pathToUse,
            wires: [] 
        };
        // √úbernehme ALLE Adern-Daten (Typ, Farbe, Querschnitt, Bezeichnungen Quelle/Ziel)
        document.querySelectorAll("#wireTable tbody tr").forEach(r => {
            const wireType = r.querySelector(".wire-type") ? r.querySelector(".wire-type").value.trim() : '';
            const wireColor = r.querySelector(".wire-color") ? r.querySelector(".wire-color").value : 'bk';
            const wireCross = r.querySelector(".wire-cross") ? r.querySelector(".wire-cross").value.trim() : '';
            const wireLabelS = r.querySelector(".wire-label-s") ? r.querySelector(".wire-label-s").value.trim() : '';
            const wireLabelE = r.querySelector(".wire-label-e") ? r.querySelector(".wire-label-e").value.trim() : '';
            
            b.wires.push({ 
                t: wireType, 
                c: wireColor, 
                cr: wireCross, 
                s: wireLabelS, 
                e: wireLabelE 
            });
        });
        
        // Wenn Muster-Modus aktiv, speichere als Muster
        if (isPatternMode && selectedPatternIndex >= 0) {
            // Pr√ºfe ob ein Pfad gezeichnet wurde (Muster wurde ausgew√§hlt und gezeichnet)
            if (pathToUse.length >= 2) {
                // Muster wurde ausgew√§hlt und gezeichnet - speichere als Kabelstrang mit ALLEN Daten aus dem Muster
                // Alle Daten (Name, Farbe, plusStart, plusEnd, alle Adern mit Typ, Farbe, Querschnitt, Bezeichnungen) 
                // sind bereits im Bundle-Objekt 'b' enthalten
                allBundles.push(b);
                // Muster-Modus zur√ºcksetzen
                isPatternMode = false;
                selectedPatternIndex = -1;
            } else {
                // Muster wurde nur bearbeitet (ohne zu zeichnen) - speichere als Muster ohne Pfad
                const patternBundle = { ...b };
                patternBundle.path = []; // Muster haben keinen Pfad
                // Setze die ausgew√§hlte Gruppe
                const selectedGroupId = document.getElementById('patternGroupSelect') ? document.getElementById('patternGroupSelect').value : null;
                if (selectedGroupId) {
                    patternBundle.groupId = selectedGroupId;
                } else {
                    // Behalte die alte Gruppe
                    patternBundle.groupId = patternBundles[selectedPatternIndex].groupId;
                }
                patternBundles[selectedPatternIndex] = patternBundle;
                updatePatternList();
                // Fr√ºh beenden, da Muster gespeichert wurde
                isPatternMode = false;
                selectedPatternIndex = -1;
                editIndex = -1;
                mode = 'none';
                document.getElementById('btnMeasure').style.background = 'var(--warning)';
                document.getElementById('btnMeasure').textContent = 'Kabelstrang zeichnen';
                document.getElementById('drawHint').style.display = 'none';
                updateSidebarList();
                rebuildDrawing();
                closeModal();
                return;
            }
        } else if (isPatternMode && selectedPatternIndex === -1) {
            // Neues Muster speichern (ohne Pfad, nur Vorlage)
            const patternBundle = { ...b };
            patternBundle.path = []; // Muster haben keinen Pfad
            // Setze die ausgew√§hlte Gruppe
            const selectedGroupId = document.getElementById('patternGroupSelect') ? document.getElementById('patternGroupSelect').value : null;
            if (selectedGroupId) {
                patternBundle.groupId = selectedGroupId;
            } else if (patternGroups.length > 0) {
                // Fallback: erste Gruppe verwenden
                patternBundle.groupId = patternGroups[0].id;
            }
            patternBundles.push(patternBundle);
            updatePatternList();
            isPatternMode = false;
            selectedPatternIndex = -1;
            editIndex = -1;
            mode = 'none';
            document.getElementById('btnMeasure').style.background = 'var(--warning)';
            document.getElementById('btnMeasure').textContent = 'Kabelstrang zeichnen';
            document.getElementById('drawHint').style.display = 'none';
            updateSidebarList();
            rebuildDrawing();
            closeModal();
            return; // Fr√ºh beenden, da Muster gespeichert wurde
        } else {
            // Normaler Modus: Als Kabelstrang speichern
        if(editIndex === -1) allBundles.push(b); else allBundles[editIndex] = b;
        }
        
        editIndex = -1;
        mode = 'none';
        isPatternMode = false;
        selectedPatternIndex = -1;
        document.getElementById('btnMeasure').style.background = 'var(--warning)';
        document.getElementById('btnMeasure').textContent = 'Kabelstrang zeichnen';
        document.getElementById('drawHint').style.display = 'none';
        updateSidebarList(); rebuildDrawing(); closeModal();
    }

    function updateSidebarList() {
        const container = document.getElementById('bundleContainer');
        container.innerHTML = "";
        allBundles.forEach((b, i) => {
            const wireCount = b.wires ? b.wires.length : 0;
            const length = b.len ? Math.round(b.len) : 0;
            container.innerHTML += `<div class="bundle-item">
                <div class="bundle-info">
                    <div class="color-dot" style="background: ${b.color}; cursor: pointer;" onclick="changeBundleColor(${i})" title="Farbe √§ndern"></div>
                    <div style="flex: 1;">
                        <div><strong>${b.name}</strong></div>
                        <div style="font-size: 0.75em; color: #94a3b8; margin-top: 4px;">
                            ${wireCount} Ader${wireCount !== 1 ? '(n)' : ''} | ${length}mm
                        </div>
                    </div>
                </div>
                <div class="bundle-actions" style="flex-direction: column; gap: 4px; flex-shrink: 0;">
                    <div style="display: flex; gap: 4px;">
                        <button class="action-btn" onclick="duplicateBundle(${i})" title="Duplizieren" style="background: var(--primary);">üìã</button>
                        <button class="action-btn" onclick="editBundle(${i})" title="Bearbeiten">‚úé</button>
                    </div>
                    <div style="display: flex; gap: 4px;">
                        <button class="action-btn" onclick="redrawBundle(${i})" style="background:var(--warning); color:black;" title="Neu zeichnen">‚Üª</button>
                        <button class="action-btn" onclick="deleteBundle(${i})" style="background:var(--danger)" title="L√∂schen">‚úï</button>
                    </div>
                </div>
            </div>`;
        });
    }

    function changeBundleColor(i) {
        const input = document.createElement('input');
        input.type = 'color';
        input.value = allBundles[i].color;
        input.onchange = (e) => {
            allBundles[i].color = e.target.value;
            updateSidebarList();
            rebuildDrawing();
        };
        input.click();
    }
    function editBundle(i) { editIndex = i; lastMeasuredLength = allBundles[i].len; openModal(); }
    function redrawBundle(i) {
        if(!mmPerPixel) { alert("Bitte zuerst den Ma√üstab festlegen!"); return; }
        editIndex = i;
        const b = allBundles[i];
        document.getElementById('drawColor').value = b.color;
        currentPath = [];
        mode = 'measure';
        document.getElementById('btnMeasure').style.background = 'var(--success)';
        document.getElementById('btnMeasure').textContent = 'Neu zeichnen: ' + b.name;
        document.getElementById('drawHint').style.display = 'block';
        rebuildDrawing();
        snapshot = ctx.getImageData(0,0,canvas.width, canvas.height);
    }
    function duplicateBundle(i) {
        const bundle = allBundles[i];
        
        // Erstelle eine tiefe Kopie des Kabelstrangs
        const duplicatedBundle = {
            name: bundle.name + ' (Kopie)',
            color: bundle.color,
            len: bundle.len || 0,
            pS: bundle.pS || 0,
            pE: bundle.pE || 0,
            path: bundle.path ? [...bundle.path] : [], // Pfad kopieren
            wires: bundle.wires ? bundle.wires.map(w => ({
                t: w.t || '',
                c: w.c || 'bk',
                cr: w.cr || '',
                s: w.s || '',
                e: w.e || ''
            })) : []
        };
        
        // F√ºge den duplizierten Kabelstrang hinzu
        allBundles.push(duplicatedBundle);
        updateSidebarList();
        rebuildDrawing();
        
        // √ñffne das Modal zum Bearbeiten des duplizierten Kabelstrangs
        editIndex = allBundles.length - 1;
        lastMeasuredLength = duplicatedBundle.len;
        
        // Lade Kabelstrang-Daten in das Modal
        document.getElementById('bundleName').value = duplicatedBundle.name;
        document.getElementById('drawColor').value = duplicatedBundle.color;
        document.getElementById('plusStart').value = duplicatedBundle.pS || 0;
        document.getElementById('plusEnd').value = duplicatedBundle.pE || 0;
        
        // Lade Adern
        const tbody = document.querySelector("#wireTable tbody");
        tbody.innerHTML = "";
        if (duplicatedBundle.wires && duplicatedBundle.wires.length > 0) {
            duplicatedBundle.wires.forEach((w, idx) => {
                tbody.innerHTML += `<tr>
                    <td>${idx + 1}</td>
                    <td><input type="text" class="wire-type" value="${(w.t || '').replace(/"/g, '&quot;')}"></td>
                    <td><select class="wire-color">
                        <option value="bk" ${w.c==='bk'?'selected':''}>Schwarz (bk)</option>
                        <option value="bl" ${w.c==='bl'?'selected':''}>Blau (bl)</option>
                        <option value="dbl" ${w.c==='dbl'?'selected':''}>Dunkelblau (dbl)</option>
                        <option value="dblws" ${w.c==='dblws'?'selected':''}>Dunkelblau-Wei√ü (dblws)</option>
                        <option value="br" ${w.c==='br'?'selected':''}>Braun (br)</option>
                        <option value="gnge" ${w.c==='gnge'?'selected':''}>Gr√ºn-Gelb (gnge)</option>
                        <option value="rt" ${w.c==='rt'?'selected':''}>Rot (rt)</option>
                        <option value="gr" ${w.c==='gr'?'selected':''}>Grau (gr)</option>
                        <option value="or" ${w.c==='or'?'selected':''}>Orange (or)</option>
                        <option value="ws" ${w.c==='ws'?'selected':''}>Wei√ü (ws)</option>
                    </select></td>
                    <td><input type="text" class="wire-cross" value="${(w.cr || '').replace(/"/g, '&quot;')}"></td>
                    <td><input type="text" class="wire-label-s" value="${(w.s || '').replace(/"/g, '&quot;')}" placeholder="z.B. F1"></td>
                    <td><input type="text" class="wire-label-e" value="${(w.e || '').replace(/"/g, '&quot;')}" placeholder="z.B. X1.1"></td>
                </tr>`;
            });
        }
        
        // Setze wireCount
        document.getElementById('wireCount').value = duplicatedBundle.wires ? duplicatedBundle.wires.length : 0;
        
        // √ñffne Modal zum Bearbeiten
        openModal();
    }
    
    function deleteBundle(i) { if(confirm("L√∂schen?")) { allBundles.splice(i, 1); updateSidebarList(); rebuildDrawing(); } }

    // ========== Muster-Kabelstr√§nge Funktionen ==========
    
    function updatePatternList() {
        const container = document.getElementById('patternContainer');
        container.innerHTML = "";
        
        // Wenn keine Gruppen vorhanden, erstelle eine Standard-Gruppe
        if (patternGroups.length === 0) {
            const defaultGroupId = 'group_' + Date.now();
            patternGroups.push({ id: defaultGroupId, name: 'Standard', collapsed: false });
            // Ordne alle vorhandenen Muster der Standard-Gruppe zu
            patternBundles.forEach(p => {
                if (!p.groupId) p.groupId = defaultGroupId;
            });
        }
        
        if (patternBundles.length === 0 && patternGroups.length === 0) {
            container.innerHTML = '<div style="text-align: center; color: #94a3b8; padding: 20px;">Keine Muster vorhanden</div>';
            return;
        }
        
        // Zeige Gruppen an
        patternGroups.forEach((group, groupIdx) => {
            // Standardm√§√üig alle Gruppen zugeklappt (true), au√üer sie wurden explizit ge√∂ffnet
            const isCollapsed = collapsedGroups[group.id] !== undefined ? collapsedGroups[group.id] : true;
            const groupPatterns = patternBundles.filter(p => p.groupId === group.id);
            
            container.innerHTML += `
                <div class="pattern-group" style="margin-bottom: 10px; border: 1px solid var(--card-border); border-radius: 8px; background: rgba(255,255,255,0.05);">
                    <div class="pattern-group-header" style="display: flex; align-items: center; justify-content: space-between; padding: 10px; cursor: pointer; user-select: none;" onclick="togglePatternGroup('${group.id}')">
                        <div style="display: flex; align-items: center; gap: 8px; flex: 1;">
                            <span style="font-size: 1.2em;">${isCollapsed ? '‚ñ∂' : '‚ñº'}</span>
                            <strong style="flex: 1;">${group.name}</strong>
                            <span style="font-size: 0.85em; color: #94a3b8;">(${groupPatterns.length} Muster)</span>
                        </div>
                        <div style="display: flex; gap: 4px;">
                            <button class="action-btn" onclick="event.stopPropagation(); renamePatternGroup('${group.id}')" title="Gruppe umbenennen" style="background: var(--primary); font-size: 12px; padding: 4px 8px;">‚úé</button>
                            <button class="action-btn" onclick="event.stopPropagation(); deletePatternGroup('${group.id}')" title="Gruppe l√∂schen" style="background: var(--danger); font-size: 12px; padding: 4px 8px;">‚úï</button>
                        </div>
                    </div>
                    <div class="pattern-group-content" style="display: ${isCollapsed ? 'none' : 'block'}; padding: 0 10px 10px 10px;">
                        ${groupPatterns.length === 0 ? 
                            '<div style="text-align: center; color: #94a3b8; padding: 10px; font-size: 0.9em;">Keine Muster in dieser Gruppe</div>' :
                            groupPatterns.map((p, idx) => {
                                const globalIndex = patternBundles.findIndex(b => b === p);
                                return `<div class="bundle-item" style="margin-top: 8px; ${selectedPatternIndex === globalIndex ? 'border: 2px solid var(--primary);' : ''}">
                                    <div class="bundle-info" style="flex: 1; min-width: 0; overflow: hidden;">
                                        <div class="color-dot" style="background: ${p.color}; flex-shrink: 0;"></div>
                                        <div style="flex: 1; min-width: 0; overflow: hidden;">
                                            <div style="word-wrap: break-word; overflow-wrap: break-word;"><strong>${p.name}</strong></div>
                                            <div style="font-size: 0.75em; color: #94a3b8; margin-top: 4px;">
                                                ${p.wires ? p.wires.length : 0} Ader(n) | ${p.len ? p.len.toFixed(0) : '?'}mm
                                            </div>
                                        </div>
                                    </div>
                                    <div class="bundle-actions" style="flex-direction: column; gap: 4px; flex-shrink: 0;">
                                        <div style="display: flex; gap: 4px;">
                                            <button class="action-btn" onclick="selectPattern(${globalIndex})" title="Muster ausw√§hlen" style="background: var(--success);">‚úì</button>
                                            <button class="action-btn" onclick="duplicatePattern(${globalIndex})" title="Duplizieren" style="background: var(--primary);">üìã</button>
                                        </div>
                                        <div style="display: flex; gap: 4px;">
                                            <button class="action-btn" onclick="editPattern(${globalIndex})" title="Bearbeiten">‚úé</button>
                                            <button class="action-btn" onclick="deletePattern(${globalIndex})" style="background: var(--danger)" title="L√∂schen">‚úï</button>
                                        </div>
                                    </div>
                                </div>`;
                            }).join('')
                        }
                    </div>
                </div>
            `;
        });
    }
    
    function togglePatternGroup(groupId) {
        collapsedGroups[groupId] = !collapsedGroups[groupId];
        updatePatternList();
    }
    
    function togglePatternManagement() {
        patternManagementCollapsed = !patternManagementCollapsed;
        const content = document.getElementById('patternManagementContent');
        const toggle = document.getElementById('patternManagementToggle');
        
        if (patternManagementCollapsed) {
            content.style.display = 'none';
            toggle.textContent = '‚ñ∂';
        } else {
            content.style.display = 'block';
            toggle.textContent = '‚ñº';
        }
    }
    
    function createPatternGroup() {
        const groupName = prompt("Bitte geben Sie den Namen der neuen Gruppe ein:");
        if (!groupName || !groupName.trim()) {
            return;
        }
        const groupId = 'group_' + Date.now();
        patternGroups.push({ id: groupId, name: groupName.trim(), collapsed: false });
        updatePatternList();
    }
    
    function renamePatternGroup(groupId) {
        const group = patternGroups.find(g => g.id === groupId);
        if (!group) return;
        const newName = prompt("Bitte geben Sie den neuen Namen ein:", group.name);
        if (newName && newName.trim()) {
            group.name = newName.trim();
            updatePatternList();
        }
    }
    
    function deletePatternGroup(groupId) {
        const group = patternGroups.find(g => g.id === groupId);
        if (!group) return;
        const groupPatterns = patternBundles.filter(p => p.groupId === groupId);
        
        if (groupPatterns.length > 0) {
            if (!confirm(`Die Gruppe "${group.name}" enth√§lt ${groupPatterns.length} Muster. M√∂chten Sie die Gruppe wirklich l√∂schen? Die Muster werden ebenfalls gel√∂scht.`)) {
                return;
            }
            // L√∂sche alle Muster dieser Gruppe
            groupPatterns.forEach(p => {
                const index = patternBundles.indexOf(p);
                if (index > -1) patternBundles.splice(index, 1);
            });
        }
        
        // L√∂sche die Gruppe
        const groupIndex = patternGroups.indexOf(group);
        if (groupIndex > -1) patternGroups.splice(groupIndex, 1);
        
        // Wenn keine Gruppen mehr vorhanden, erstelle Standard-Gruppe
        if (patternGroups.length === 0) {
            const defaultGroupId = 'group_' + Date.now();
            patternGroups.push({ id: defaultGroupId, name: 'Standard', collapsed: false });
        }
        
        updatePatternList();
    }
    
    function deletePatternGroupFromList() {
        if (patternGroups.length === 0) {
            alert("Keine Gruppen vorhanden!");
            return;
        }
        
        // Erstelle Auswahl-Liste
        let groupList = "Bitte w√§hlen Sie die zu l√∂schende Gruppe:\n\n";
        patternGroups.forEach((group, index) => {
            const groupPatterns = patternBundles.filter(p => p.groupId === group.id);
            groupList += `${index + 1}. ${group.name} (${groupPatterns.length} Muster)\n`;
        });
        
        const selection = prompt(groupList + "\nGeben Sie die Nummer ein:");
        if (!selection) return;
        
        const selectedIndex = parseInt(selection) - 1;
        if (isNaN(selectedIndex) || selectedIndex < 0 || selectedIndex >= patternGroups.length) {
            alert("Ung√ºltige Auswahl!");
            return;
        }
        
        const selectedGroup = patternGroups[selectedIndex];
        deletePatternGroup(selectedGroup.id);
    }
    
    function selectPattern(i) {
        if (!mmPerPixel) {
            alert("Bitte zuerst den Ma√üstab festlegen!");
            return;
        }
        selectedPatternIndex = i;
        isPatternMode = true;
        const pattern = patternBundles[i];
        
        // Lade ALLE Muster-Daten in das Modal (Name, Farbe, plusStart, plusEnd, alle Adern)
        document.getElementById('bundleName').value = pattern.name || '';
        document.getElementById('drawColor').value = pattern.color || '#f39c12';
        document.getElementById('plusStart').value = pattern.pS || 0;
        document.getElementById('plusEnd').value = pattern.pE || 0;
        
        // Lade ALLE Adern-Daten (Typ, Farbe, Querschnitt, Bezeichnungen)
        // WICHTIG: Setze wireCount, damit updateWireTable() nicht die Daten √ºberschreibt
        document.getElementById('wireCount').value = pattern.wires ? pattern.wires.length : 0;
        
        const tbody = document.querySelector("#wireTable tbody");
        tbody.innerHTML = "";
        if (pattern.wires && pattern.wires.length > 0) {
            pattern.wires.forEach((w, idx) => {
                tbody.innerHTML += `<tr>
                    <td>${idx + 1}</td>
                    <td><input type="text" class="wire-type" value="${(w.t || '').replace(/"/g, '&quot;')}"></td>
                    <td><select class="wire-color">
                        <option value="bk" ${w.c==='bk'?'selected':''}>Schwarz (bk)</option>
                        <option value="bl" ${w.c==='bl'?'selected':''}>Blau (bl)</option>
                        <option value="dbl" ${w.c==='dbl'?'selected':''}>Dunkelblau (dbl)</option>
                        <option value="dblws" ${w.c==='dblws'?'selected':''}>Dunkelblau-Wei√ü (dblws)</option>
                        <option value="br" ${w.c==='br'?'selected':''}>Braun (br)</option>
                        <option value="gnge" ${w.c==='gnge'?'selected':''}>Gr√ºn-Gelb (gnge)</option>
                        <option value="rt" ${w.c==='rt'?'selected':''}>Rot (rt)</option>
                        <option value="gr" ${w.c==='gr'?'selected':''}>Grau (gr)</option>
                        <option value="or" ${w.c==='or'?'selected':''}>Orange (or)</option>
                        <option value="ws" ${w.c==='ws'?'selected':''}>Wei√ü (ws)</option>
                    </select></td>
                    <td><input type="text" class="wire-cross" value="${(w.cr || '').replace(/"/g, '&quot;')}"></td>
                    <td><input type="text" class="wire-label-s" value="${(w.s || '').replace(/"/g, '&quot;')}" placeholder="z.B. F1"></td>
                    <td><input type="text" class="wire-label-e" value="${(w.e || '').replace(/"/g, '&quot;')}" placeholder="z.B. X1.1"></td>
                </tr>`;
            });
        }
        
        // NICHT Modal √∂ffnen - nur Daten laden und Zeichnen-Modus starten
        // Das Modal wird erst beim Speichern ge√∂ffnet, damit der Benutzer zeichnen kann
        
        // Starte Zeichnen-Modus
        currentPath = [];
        mode = 'measure';
        editIndex = -1; // Wichtig: Nicht als normalen Kabelstrang bearbeiten
        document.getElementById('btnMeasure').style.background = 'var(--success)';
        document.getElementById('btnMeasure').textContent = 'Muster zeichnen: ' + pattern.name;
        document.getElementById('drawHint').style.display = 'block';
        updatePatternList();
        rebuildDrawing();
    }
    
    function openPatternModal() {
        // √ñffne Modal f√ºr neues Muster
        selectedPatternIndex = -1;
        isPatternMode = true;
        document.getElementById('bundleName').value = '';
        document.getElementById('drawColor').value = '#f39c12';
        document.getElementById('plusStart').value = 0;
        document.getElementById('plusEnd').value = 0;
        document.querySelector("#wireTable tbody").innerHTML = "";
        
        // Zeige Gruppenauswahl und f√ºlle sie
        updatePatternGroupSelector();
        document.getElementById('patternGroupSelector').style.display = 'block';
        
        openModal();
    }
    
    function updatePatternGroupSelector() {
        const select = document.getElementById('patternGroupSelect');
        select.innerHTML = '';
        
        // Wenn keine Gruppen vorhanden, erstelle eine Standard-Gruppe
        if (patternGroups.length === 0) {
            const defaultGroupId = 'group_' + Date.now();
            patternGroups.push({ id: defaultGroupId, name: 'Standard', collapsed: false });
        }
        
        patternGroups.forEach(group => {
            const option = document.createElement('option');
            option.value = group.id;
            option.textContent = group.name;
            select.appendChild(option);
        });
    }
    
    function editPattern(i) {
        selectedPatternIndex = i;
        isPatternMode = true;
        const pattern = patternBundles[i];
        
        // Lade Muster-Daten in das Modal
        document.getElementById('bundleName').value = pattern.name;
        document.getElementById('drawColor').value = pattern.color;
        document.getElementById('plusStart').value = pattern.pS || 0;
        document.getElementById('plusEnd').value = pattern.pE || 0;
        
        // Lade Adern
        const tbody = document.querySelector("#wireTable tbody");
        tbody.innerHTML = "";
        pattern.wires.forEach(w => {
            tbody.innerHTML += `<tr>
                <td><input type="text" class="wire-type" value="${w.t}"></td>
                <td><select class="wire-color">
                    <option value="bk" ${w.c==='bk'?'selected':''}>Schwarz (bk)</option>
                    <option value="bl" ${w.c==='bl'?'selected':''}>Blau (bl)</option>
                    <option value="dbl" ${w.c==='dbl'?'selected':''}>Dunkelblau (dbl)</option>
                    <option value="dblws" ${w.c==='dblws'?'selected':''}>Dunkelblau-Wei√ü (dblws)</option>
                    <option value="br" ${w.c==='br'?'selected':''}>Braun (br)</option>
                    <option value="gnge" ${w.c==='gnge'?'selected':''}>Gr√ºn-Gelb (gnge)</option>
                    <option value="rt" ${w.c==='rt'?'selected':''}>Rot (rt)</option>
                    <option value="gr" ${w.c==='gr'?'selected':''}>Grau (gr)</option>
                    <option value="or" ${w.c==='or'?'selected':''}>Orange (or)</option>
                    <option value="ws" ${w.c==='ws'?'selected':''}>Wei√ü (ws)</option>
                </select></td>
                <td><input type="text" class="wire-cross" value="${w.cr}"></td>
                <td><input type="text" class="wire-label-s" value="${w.s}" placeholder="z.B. F1"></td>
                <td><input type="text" class="wire-label-e" value="${w.e}" placeholder="z.B. X1.1"></td>
                <td><button class="action-btn" onclick="this.parentElement.parentElement.remove()" style="background: var(--danger); width: 24px; height: 24px; font-size: 12px;">‚úï</button></td>
            </tr>`;
        });
        
        // Zeige Gruppenauswahl und setze die aktuelle Gruppe
        updatePatternGroupSelector();
        document.getElementById('patternGroupSelector').style.display = 'block';
        if (pattern.groupId) {
            document.getElementById('patternGroupSelect').value = pattern.groupId;
        } else if (patternGroups.length > 0) {
            document.getElementById('patternGroupSelect').value = patternGroups[0].id;
        }
        
        openModal();
    }
    
    function duplicatePattern(i) {
        const pattern = patternBundles[i];
        
        // Erstelle eine tiefe Kopie des Musters
        const duplicatedPattern = {
            name: pattern.name + ' (Kopie)',
            color: pattern.color,
            len: pattern.len || 0,
            pS: pattern.pS || 0,
            pE: pattern.pE || 0,
            path: [],
            wires: pattern.wires ? pattern.wires.map(w => ({
                t: w.t || '',
                c: w.c || 'bk',
                cr: w.cr || '',
                s: w.s || '',
                e: w.e || ''
            })) : []
        };
        
        // F√ºge das duplizierte Muster hinzu
        patternBundles.push(duplicatedPattern);
        updatePatternList();
        
        // √ñffne das Modal zum Bearbeiten des duplizierten Musters
        selectedPatternIndex = patternBundles.length - 1;
        isPatternMode = true;
        editIndex = -1; // Wichtig: Nicht als normalen Kabelstrang bearbeiten
        
        // Lade Muster-Daten in das Modal
        document.getElementById('bundleName').value = duplicatedPattern.name;
        document.getElementById('drawColor').value = duplicatedPattern.color;
        document.getElementById('plusStart').value = duplicatedPattern.pS || 0;
        document.getElementById('plusEnd').value = duplicatedPattern.pE || 0;
        
        // Lade Adern
        const tbody = document.querySelector("#wireTable tbody");
        tbody.innerHTML = "";
        if (duplicatedPattern.wires && duplicatedPattern.wires.length > 0) {
            duplicatedPattern.wires.forEach((w, idx) => {
                tbody.innerHTML += `<tr>
                    <td>${idx + 1}</td>
                    <td><input type="text" class="wire-type" value="${(w.t || '').replace(/"/g, '&quot;')}"></td>
                    <td><select class="wire-color">
                        <option value="bk" ${w.c==='bk'?'selected':''}>Schwarz (bk)</option>
                        <option value="bl" ${w.c==='bl'?'selected':''}>Blau (bl)</option>
                        <option value="dbl" ${w.c==='dbl'?'selected':''}>Dunkelblau (dbl)</option>
                        <option value="dblws" ${w.c==='dblws'?'selected':''}>Dunkelblau-Wei√ü (dblws)</option>
                        <option value="br" ${w.c==='br'?'selected':''}>Braun (br)</option>
                        <option value="gnge" ${w.c==='gnge'?'selected':''}>Gr√ºn-Gelb (gnge)</option>
                        <option value="rt" ${w.c==='rt'?'selected':''}>Rot (rt)</option>
                        <option value="gr" ${w.c==='gr'?'selected':''}>Grau (gr)</option>
                        <option value="or" ${w.c==='or'?'selected':''}>Orange (or)</option>
                        <option value="ws" ${w.c==='ws'?'selected':''}>Wei√ü (ws)</option>
                    </select></td>
                    <td><input type="text" class="wire-cross" value="${(w.cr || '').replace(/"/g, '&quot;')}"></td>
                    <td><input type="text" class="wire-label-s" value="${(w.s || '').replace(/"/g, '&quot;')}" placeholder="z.B. F1"></td>
                    <td><input type="text" class="wire-label-e" value="${(w.e || '').replace(/"/g, '&quot;')}" placeholder="z.B. X1.1"></td>
                </tr>`;
            });
        }
        
        // Setze wireCount
        document.getElementById('wireCount').value = duplicatedPattern.wires ? duplicatedPattern.wires.length : 0;
        
        // Zeige Gruppenauswahl und setze die Gruppe des Original-Musters
        updatePatternGroupSelector();
        document.getElementById('patternGroupSelector').style.display = 'block';
        if (pattern.groupId) {
            document.getElementById('patternGroupSelect').value = pattern.groupId;
        }
        
        // √ñffne Modal zum Bearbeiten
        openModal();
        
        // Fokussiere das Name-Feld, damit der Benutzer den Namen direkt √§ndern kann
        setTimeout(() => {
            const nameField = document.getElementById('bundleName');
            if (nameField) {
                nameField.focus();
                nameField.select(); // Markiere den Text, damit er direkt √ºberschrieben werden kann
            }
        }, 100);
    }
    
    function deletePattern(i) {
        if (confirm("Muster wirklich l√∂schen?")) {
            patternBundles.splice(i, 1);
            updatePatternList();
        }
    }
    
    function exportPatterns() {
        if (patternBundles.length === 0) {
            alert("Keine Muster zum Exportieren vorhanden!");
            return;
        }
        
        // Frage den Benutzer nach dem Dateinamen
        let fileName = patternListName || 'uwe-muster';
        const userInput = prompt("Bitte geben Sie den Dateinamen ein (ohne .json):", fileName);
        
        if (userInput === null) {
            // Benutzer hat Abbrechen gedr√ºckt
            return;
        }
        
        fileName = userInput.trim();
        if (!fileName) {
            alert("Bitte geben Sie einen g√ºltigen Dateinamen ein!");
            return;
        }
        
        // Speichere den Dateinamen als Muster-Listen-Namen
        patternListName = fileName;
        updatePatternListTitle();
        
        try {
            const dataStr = JSON.stringify({ 
                patterns: patternBundles,
                groups: patternGroups,
                listName: patternListName 
            }, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName + '.json';
            a.click();
            URL.revokeObjectURL(url);
        } catch (e) {
            alert("Fehler beim Exportieren: " + e.message);
        }
    }
    
    function importPatterns(event) {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onerror = () => alert("Fehler beim Laden der Datei!");
        reader.onload = (f) => {
            try {
                const data = JSON.parse(f.target.result);
                if (data.patterns && Array.isArray(data.patterns)) {
                    patternBundles = data.patterns;
                    
                    // Lade Gruppen, falls vorhanden
                    if (data.groups && Array.isArray(data.groups)) {
                        patternGroups = data.groups;
                    } else {
                        // Fallback: Erstelle Standard-Gruppe f√ºr alle Muster ohne Gruppe
                        const defaultGroupId = 'group_' + Date.now();
                        patternGroups = [{ id: defaultGroupId, name: 'Standard', collapsed: false }];
                        patternBundles.forEach(p => {
                            if (!p.groupId) p.groupId = defaultGroupId;
                        });
                    }
                    
                    // Extrahiere den Dateinamen (ohne .json) und verwende ihn als Muster-Listen-Namen
                    const fileName = file.name.replace(/\.json$/i, '');
                    patternListName = data.listName || fileName;
                    
                    updatePatternListTitle();
                    updatePatternList();
                    alert(`${data.patterns.length} Muster in ${patternGroups.length} Gruppe(n) erfolgreich importiert!`);
                } else {
                    alert("Ung√ºltiges Dateiformat!");
                }
            } catch (e) {
                alert("Fehler beim Lesen der Datei: " + e.message);
            }
        };
        reader.readAsText(file);
        event.target.value = ''; // Reset input
    }
    
    function updatePatternListTitle() {
        const titleElement = document.getElementById('patternListTitle');
        if (patternListName) {
            titleElement.textContent = 'Muster-Liste: ' + patternListName;
        } else {
            titleElement.textContent = 'Muster-Liste';
        }
    }
    
    // Initialisiere Muster-Liste beim Start
    // Erstelle Standard-Gruppe, falls keine vorhanden
    if (patternGroups.length === 0) {
        const defaultGroupId = 'group_' + Date.now();
        patternGroups.push({ id: defaultGroupId, name: 'Standard', collapsed: false });
    }
    updatePatternListTitle();
    updatePatternList();

    function autoFill(cls, inc) {
        const rows = document.querySelectorAll("#wireTable tbody tr");
        const val = rows[0].querySelector("."+cls).value;
        for(let i=1; i<rows.length; i++) {
            const f = rows[i].querySelector("."+cls);
            if(inc) {
                const m = val.match(/(\d+)$/);
                if(!m) { f.value = val; continue; }
                f.value = val.substring(0, val.length-m[1].length) + (parseInt(m[1])+i).toString().padStart(m[1].length, '0');
            } else f.value = val;
        }
    }

    function saveProjectJSON() {
        if (allBundles.length === 0 && !originalImageSnapshot) {
            alert("Keine Daten zum Speichern vorhanden!");
            return;
        }
        const defaultName = "UWE_Projekt_" + new Date().toISOString().split('T')[0];
        const fileName = prompt("Dateiname eingeben:", defaultName);
        if (fileName === null) return; // Abbrechen
        
        const projectData = { 
            version: "1.0",
            mmPerPixel, 
            realLengthValue: document.getElementById('realLength').value, 
            bundles: allBundles,
            imageData: img.src && img.src.startsWith('data:') ? img.src : null,
            exportDate: new Date().toISOString()
        };
        try {
            const blob = new Blob([JSON.stringify(projectData, null, 2)], { type: 'application/json' });
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
            a.download = (fileName.trim() || defaultName) + ".json";
        a.click();
            URL.revokeObjectURL(a.href);
        } catch(err) {
            alert("Fehler beim Speichern: " + err.message);
        }
    }

    function loadProjectJSON(event) {
        if (!event.target.files || !event.target.files[0]) return;
        const reader = new FileReader();
        reader.onerror = () => alert("Fehler beim Laden der Datei!");
        reader.onload = (e) => {
            try {
            const data = JSON.parse(e.target.result);
                allBundles = data.bundles || [];
                mmPerPixel = data.mmPerPixel || 0;
                document.getElementById('realLength').value = data.realLengthValue || 0;
            document.getElementById('btnMeasure').disabled = false;
                
                // Bild laden falls vorhanden
                if (data.imageData) {
                    img.onload = () => {
                        if (autoFitToWindow) {
                            resizeCanvas();
                        } else {
                            canvas.width = img.width; 
                            canvas.height = img.height;
                            imageScale = 1;
                            imageOffsetX = 0;
                            imageOffsetY = 0;
                        }
                        // Reset Zoom und Pan beim Laden eines Projekts
                        zoom = 1;
                        panX = 0;
                        panY = 0;
                        originalImageSnapshot = ctx.getImageData(0,0,canvas.width, canvas.height);
            rebuildDrawing();
                    };
                    img.onerror = () => alert("Fehler beim Laden des Bildes!");
                    img.src = data.imageData;
                }
                
                updateSidebarList();
                if(originalImageSnapshot) rebuildDrawing();
            } catch(err) {
                alert("Fehler: Ung√ºltige Projektdatei! " + err.message);
            }
        };
        reader.readAsText(event.target.files[0]);
    }

    function exportWustec() {
        if (allBundles.length === 0) {
            alert("Keine Kabelstr√§nge vorhanden!");
            return;
        }
        let csv = "ID;Quelle;Ziel;Querschnitt;Farbe;L√§nge_mm;Drucktext_Quelle;Drucktext_Ziel;Ader-Typ;Crimpung_Quelle;Crimpung_Ziel;Reserve_mm;BMK_Quelle;BMK_Ziel\n";
        allBundles.forEach((b, bi) => {
            if (!b.wires || b.wires.length === 0) return;
            b.wires.forEach((w, wi) => {
            const len = Math.round(b.len+b.pS+b.pE);
                csv += `${bi+1}_${wi+1};${w.s || ''};${b.name || ''};${w.cr || ''};${w.c || ''};${len};${w.s || ''};${w.e || ''};${w.t || ''};Aderendh√ºlse;Aderendh√ºlse;0;${b.name || ''};${b.name || ''}\n`;
            });
        });
        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const a = document.createElement("a"); 
        a.href = URL.createObjectURL(blob); 
        a.download = "Wustec_Export_" + new Date().toISOString().split('T')[0] + ".csv"; 
        a.click();
        URL.revokeObjectURL(a.href);
    }

    function exportVisual() {
        if (!img.complete || img.width === 0 || allBundles.length === 0) {
            alert("Keine Daten zum Exportieren vorhanden!");
            return;
        }
        
        // Erstelle ein tempor√§res Canvas mit Original-Bildgr√∂√üe (ohne autoFitToWindow)
        const imageCanvas = document.createElement('canvas');
        imageCanvas.width = img.width;
        imageCanvas.height = img.height;
        const imgCtx = imageCanvas.getContext('2d');
        
        // Zeichne das Bild in Originalgr√∂√üe
        imgCtx.drawImage(img, 0, 0);
        
        // Zeichne alle Str√§nge in Original-Bildkoordinaten (ohne Transformationen)
        allBundles.forEach(b => {
            if (!b.path || b.path.length === 0) return;
            imgCtx.strokeStyle = b.color;
            imgCtx.lineWidth = Math.max(4, img.width / 500);
            imgCtx.beginPath();
            imgCtx.moveTo(b.path[0].x, b.path[0].y);
            b.path.forEach(p => imgCtx.lineTo(p.x, p.y));
            imgCtx.stroke();
        });
        
        // Erstelle das Export-Canvas mit Bild + Legende
        const tempCanvas = document.createElement('canvas');
        const legendWidth = 350; // Breite f√ºr die Legende
        const padding = 20; // Abstand zwischen Bild und Legende
        tempCanvas.width = img.width + legendWidth + padding; 
        tempCanvas.height = Math.max(img.height, (allBundles.length * 30) + 100);
        const tCtx = tempCanvas.getContext('2d');
        tCtx.fillStyle = "white"; 
        tCtx.fillRect(0,0,tempCanvas.width, tempCanvas.height);
        
        // Zeichne das Bild in Originalgr√∂√üe links
        tCtx.drawImage(imageCanvas, 0, 0);
        
        // Zeichne die Legende rechts neben dem Bild
        const legendX = img.width + padding;
        tCtx.fillStyle = "black"; 
        tCtx.font = "bold 24px Arial"; 
        tCtx.fillText("Legende Kabelstr√§nge (UWE)", legendX, 40);
        allBundles.forEach((b, i) => {
            const y = 80 + (i*30);
            tCtx.fillStyle = b.color || '#000000';
            tCtx.beginPath(); 
            tCtx.arc(legendX + 30, y-8, 10, 0, Math.PI*2); 
            tCtx.fill();
            tCtx.fillStyle = "black"; 
            tCtx.font = "18px Arial";
            const wireCount = b.wires ? b.wires.length : 0;
            const totalLength = Math.round((b.len || 0) + (b.pS || 0) + (b.pE || 0));
            tCtx.fillText(`${b.name || 'Unbenannt'}: ${wireCount} Adern, ca. ${totalLength}mm`, legendX + 55, y);
        });
        const a = document.createElement("a"); 
        a.href = tempCanvas.toDataURL('image/png'); 
        a.download = "UWE_Doku_" + new Date().toISOString().split('T')[0] + ".png"; 
        a.click();
    }
    
    // ========== Hilfe/Anleitung Funktionen ==========
    
    function openHelpWindow() {
        const helpWindow = window.open('', 'UWE_Anleitung', 'width=800,height=700,scrollbars=yes,resizable=yes');
        if (!helpWindow) {
            alert('Bitte erlauben Sie Popups f√ºr diese Seite, um die Anleitung zu √∂ffnen.');
            return;
        }
        
        helpWindow.document.write(`
            <!DOCTYPE html>
            <html lang="de">
            <head>
                <meta charset="UTF-8">
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <title>UWE - Anleitung</title>
                <style>
                    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
                    * { box-sizing: border-box; margin: 0; padding: 0; }
                    body {
                        font-family: 'Inter', sans-serif;
                        background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
                        color: white;
                        padding: 30px;
                        line-height: 1.6;
                    }
                    .container {
                        max-width: 750px;
                        margin: 0 auto;
                        background: rgba(30, 41, 59, 0.9);
                        padding: 30px;
                        border-radius: 12px;
                        box-shadow: 0 8px 32px rgba(0,0,0,0.3);
                    }
                    h1 {
                        color: #6366f1;
                        margin-bottom: 10px;
                        font-size: 2em;
                        border-bottom: 2px solid rgba(99, 102, 241, 0.3);
                        padding-bottom: 10px;
                    }
                    h2 {
                        color: #8b5cf6;
                        margin-top: 25px;
                        margin-bottom: 15px;
                        font-size: 1.4em;
                    }
                    h3 {
                        color: #a78bfa;
                        margin-top: 20px;
                        margin-bottom: 10px;
                        font-size: 1.2em;
                    }
                    p {
                        margin-bottom: 12px;
                    }
                    ul, ol {
                        margin-left: 25px;
                        margin-bottom: 15px;
                    }
                    li {
                        margin-bottom: 8px;
                    }
                    .section {
                        margin-bottom: 30px;
                        padding: 20px;
                        background: rgba(255,255,255,0.05);
                        border-radius: 8px;
                        border-left: 4px solid #6366f1;
                    }
                    .highlight {
                        background: rgba(99, 102, 241, 0.2);
                        padding: 2px 6px;
                        border-radius: 4px;
                        font-weight: 600;
                    }
                    code {
                        background: rgba(0,0,0,0.3);
                        padding: 2px 6px;
                        border-radius: 4px;
                        font-family: 'Courier New', monospace;
                        font-size: 0.9em;
                    }
                    .tip {
                        background: rgba(16, 185, 129, 0.2);
                        border-left: 4px solid #10b981;
                        padding: 12px;
                        margin: 15px 0;
                        border-radius: 4px;
                    }
                    .warning {
                        background: rgba(239, 68, 68, 0.2);
                        border-left: 4px solid #ef4444;
                        padding: 12px;
                        margin: 15px 0;
                        border-radius: 4px;
                    }
                </style>
            </head>
            <body>
                <div class="container">
                    <h1>üìò UWE - Universal Wiring Engine</h1>
                    <p><strong>Anleitung zur Verwendung der Anwendung</strong></p>
                    
                    <div class="section">
                        <h2>1. Grundlagen</h2>
                        <p>UWE ist eine professionelle Anwendung zur Erfassung und Dokumentation von Kabelb√§umen mit Ma√üstab-Messung und verschiedenen Export-Funktionen.</p>
                        
                        <h3>1.1 Bild laden</h3>
                        <ol>
                            <li>Klicken Sie auf <span class="highlight">"Bild ausw√§hlen"</span> im ersten Schritt</li>
                            <li>W√§hlen Sie eine Bilddatei von Ihrem Computer</li>
                            <li>Das Bild wird automatisch geladen und angezeigt</li>
                        </ol>
                        
                        <h3>1.2 Ma√üstab festlegen</h3>
                        <ol>
                            <li>Messen Sie eine bekannte L√§nge im Bild (z.B. mit einem Lineal am Bildschirm)</li>
                            <li>Geben Sie die L√§nge in <span class="highlight">Millimetern (mm)</span> ein</li>
                            <li>Klicken Sie auf <span class="highlight">"Ma√üstab festlegen"</span></li>
                            <li>Zeichnen Sie eine Linie im Bild √ºber die gemessene Strecke</li>
                            <li>Best√§tigen Sie mit <span class="highlight">"Ma√üstab best√§tigen ‚úì"</span></li>
                        </ol>
                        <div class="tip">
                            üí° <strong>Tipp:</strong> Je l√§nger die Referenzstrecke, desto genauer wird der Ma√üstab!
                        </div>
                    </div>
                    
                    <div class="section">
                        <h2>2. Kabelstr√§nge zeichnen</h2>
                        <h3>2.1 Kabelstrang erstellen</h3>
                        <ol>
                            <li>W√§hlen Sie eine <span class="highlight">Farbe</span> f√ºr den Kabelstrang</li>
                            <li>Klicken Sie auf <span class="highlight">"Kabelstrang zeichnen"</span></li>
                            <li>Klicken Sie mit der Maus im Bild, um Punkte zu setzen</li>
                            <li><strong>Doppelklick</strong> beendet das Zeichnen</li>
                            <li>Geben Sie im ge√∂ffneten Dialog den <span class="highlight">Namen</span> ein</li>
                            <li>F√ºgen Sie <span class="highlight">Zuschl√§ge</span> (Vorn/Hinten in mm) hinzu</li>
                            <li>Definieren Sie die <span class="highlight">Adern</span> mit Typ, Farbe, Querschnitt (mm¬≤) und Bezeichnungen</li>
                            <li>Klicken Sie auf <span class="highlight">"Speichern"</span></li>
                        </ol>
                        <div class="tip">
                            üí° <strong>Tipp:</strong> Doppelklick beendet das Zeichnen eines Kabelstrangs automatisch!
                        </div>
                        
                        <h3>2.2 Kabelstrang bearbeiten</h3>
                        <ul>
                            <li>Klicken Sie auf <span class="highlight">‚úé</span> (Bearbeiten) in der Kabelstrang-Liste</li>
                            <li>√Ñndern Sie die gew√ºnschten Werte</li>
                            <li>Speichern Sie die √Ñnderungen</li>
                        </ul>
                        
                        <h3>2.3 Kabelstrang neu zeichnen</h3>
                        <ul>
                            <li>Klicken Sie auf <span class="highlight">‚Üª</span> (Neu zeichnen)</li>
                            <li>Zeichnen Sie einen neuen Pfad</li>
                            <li>Alle anderen Daten (Name, Adern, etc.) bleiben erhalten</li>
                        </ul>
                        
                        <h3>2.4 Kabelstrang duplizieren</h3>
                        <ul>
                            <li>Klicken Sie auf <span class="highlight">üìã</span> (Duplizieren)</li>
                            <li>Der Kabelstrang wird kopiert und zum Bearbeiten ge√∂ffnet</li>
                            <li>√Ñndern Sie den Namen und speichern Sie</li>
                        </ul>
                        
                        <h3>2.5 Farbe √§ndern</h3>
                        <ul>
                            <li>Klicken Sie auf den <span class="highlight">Farbpunkt</span> neben dem Kabelstrang-Namen</li>
                            <li>W√§hlen Sie eine neue Farbe aus dem Farbw√§hler</li>
                        </ul>
                    </div>
                    
                    <div class="section">
                        <h2>3. Navigation im Bild</h2>
                        <h3>3.1 Zoomen</h3>
                        <ul>
                            <li>Verwenden Sie das <span class="highlight">Mausrad</span> zum Zoomen</li>
                            <li>Das Bild zoomt zum Mauszeiger hin (Zoom-Zentrum am Mauszeiger)</li>
                            <li>Zoom-Bereich: 10% bis 500%</li>
                        </ul>
                        
                        <h3>3.2 Verschieben (Panning)</h3>
                        <ul>
                            <li>Halten Sie die <span class="highlight">mittlere Maustaste</span> gedr√ºckt</li>
                            <li>Bewegen Sie die Maus, um das Bild zu verschieben</li>
                        </ul>
                        
                        <h3>3.3 Bild automatisch an Fenster anpassen</h3>
                        <ul>
                            <li>Aktivieren Sie die <span class="highlight">Checkbox "Bild wird automatisch an Fenster angepasst"</span></li>
                            <li>Das Bild wird automatisch skaliert, um optimal in das Fenster zu passen</li>
                            <li>Zum Zur√ºcksetzen die Checkbox deaktivieren</li>
                        </ul>
                    </div>
                    
                    <div class="section">
                        <h2>4. Muster-Kabelstr√§nge</h2>
                        <h3>4.1 Muster erstellen</h3>
                        <ol>
                            <li>Klicken Sie auf <span class="highlight">"+ Neues Muster"</span></li>
                            <li>Geben Sie alle Daten ein (Name, Farbe, Adern, etc.)</li>
                            <li>W√§hlen Sie eine <span class="highlight">Gruppe</span> aus oder erstellen Sie eine neue</li>
                            <li>Speichern Sie das Muster (ohne Pfad - nur Vorlage)</li>
                        </ol>
                        
                        <h3>4.2 Muster ausw√§hlen und zeichnen</h3>
                        <ol>
                            <li>Klicken Sie auf <span class="highlight">‚úì</span> (Muster ausw√§hlen) bei einem Muster</li>
                            <li>Alle Muster-Daten werden geladen</li>
                            <li>Zeichnen Sie den Pfad im Bild (wie bei normalen Kabelstr√§ngen)</li>
                            <li>Nach dem <strong>Doppelklick</strong> √∂ffnet sich das Modal mit allen Daten</li>
                            <li>Speichern Sie - der Kabelstrang wird automatisch zur Liste hinzugef√ºgt</li>
                        </ol>
                        
                        <h3>4.3 Gruppen verwalten</h3>
                        <ul>
                            <li><strong>Neue Gruppe:</strong> Klicken Sie auf <span class="highlight">"+ Neue Gruppe"</span></li>
                            <li><strong>Gruppe umbenennen:</strong> Klicken Sie auf <span class="highlight">‚úé</span> im Gruppen-Header</li>
                            <li><strong>Gruppe l√∂schen:</strong> Klicken Sie auf <span class="highlight">‚úï</span> im Gruppen-Header oder verwenden Sie den Button <span class="highlight">"Gruppe l√∂schen"</span></li>
                            <li><strong>Auf-/Zuklappen:</strong> Klicken Sie auf den Gruppen-Header (‚ñ∂ = zugeklappt, ‚ñº = aufgeklappt)</li>
                        </ul>
                        <div class="tip">
                            üí° <strong>Tipp:</strong> Gruppen werden standardm√§√üig zugeklappt, um die √úbersicht zu verbessern!
                        </div>
                        
                        <h3>4.4 Muster duplizieren</h3>
                        <ul>
                            <li>Klicken Sie auf <span class="highlight">üìã</span> (Duplizieren)</li>
                            <li>Das Muster wird kopiert und zum Bearbeiten ge√∂ffnet</li>
                            <li>√Ñndern Sie den Namen und die gew√ºnschten Daten</li>
                            <li>W√§hlen Sie eine Gruppe f√ºr das duplizierte Muster</li>
                            <li>Speichern Sie</li>
                        </ul>
                        
                        <h3>4.5 Muster exportieren/importieren</h3>
                        <ul>
                            <li><strong>Export:</strong> Klicken Sie auf <span class="highlight">"Muster exportieren"</span> - Dateiname wird abgefragt</li>
                            <li><strong>Import:</strong> Klicken Sie auf <span class="highlight">"üì• Muster importieren"</span> und w√§hlen Sie eine JSON-Datei</li>
                            <li>Muster k√∂nnen unabh√§ngig von Projekten gespeichert und geladen werden</li>
                            <li>Beim Import wird der Dateiname als Titel der Muster-Liste angezeigt</li>
                        </ul>
                    </div>
                    
                    <div class="section">
                        <h2>5. Projekt-Verwaltung</h2>
                        <h3>5.1 Projekt speichern</h3>
                        <ol>
                            <li>Klicken Sie auf <span class="highlight">"Speichern"</span> im Projekt-Speicher-Bereich</li>
                            <li>Geben Sie einen Dateinamen ein (Standard wird vorgeschlagen)</li>
                            <li>Das Projekt wird als JSON-Datei gespeichert</li>
                            <li><span class="highlight">Enth√§lt:</span> Bild, Ma√üstab, alle Kabelstr√§nge mit Pfaden und Adern</li>
                        </ol>
                        
                        <h3>5.2 Projekt laden</h3>
                        <ol>
                            <li>Klicken Sie auf <span class="highlight">"Laden"</span></li>
                            <li>W√§hlen Sie eine gespeicherte Projektdatei (JSON)</li>
                            <li>Alle Daten werden automatisch geladen</li>
                        </ol>
                        <div class="warning">
                            ‚ö†Ô∏è <strong>Hinweis:</strong> Beim Laden eines Projekts werden alle aktuellen Daten √ºberschrieben!
                        </div>
                    </div>
                    
                    <div class="section">
                        <h2>6. Export-Funktionen</h2>
                        <h3>6.1 Wustec Export (CSV)</h3>
                        <ul>
                            <li>Klicken Sie auf <span class="highlight">"Wustec Export (.csv)"</span></li>
                            <li>Eine CSV-Datei wird heruntergeladen</li>
                            <li>Enth√§lt alle Kabelstr√§nge mit Adern-Details</li>
                            <li>Kompatibel mit Wustec-Software</li>
                        </ul>
                        
                        <h3>6.2 Bild & Legende Export</h3>
                        <ul>
                            <li>Klicken Sie auf <span class="highlight">"Bild & Legende Export"</span></li>
                            <li>Ein kombiniertes Bild wird erstellt</li>
                            <li>Bild wird immer in <strong>Originalgr√∂√üe</strong> exportiert (unabh√§ngig von Zoom/Einstellungen)</li>
                            <li>Legende wird rechts neben dem Bild angezeigt</li>
                            <li>Dateiname enth√§lt automatisch das Datum</li>
                        </ul>
                    </div>
                    
                    <div class="section">
                        <h2>7. Tastenk√ºrzel & Interaktionen</h2>
                        <ul>
                            <li><strong>Mausrad:</strong> Zoomen (zoomt zum Mauszeiger hin)</li>
                            <li><strong>Mittlere Maustaste:</strong> Bild verschieben (Panning)</li>
                            <li><strong>Doppelklick:</strong> Zeichnen beenden</li>
                            <li><strong>Farbpunkt klicken:</strong> Farbe √§ndern</li>
                            <li><strong>Button-Hover:</strong> Tooltips mit Beschreibungen anzeigen</li>
                        </ul>
                    </div>
                    
                    <div class="section">
                        <h2>8. Unterst√ºtzte Adern-Farben</h2>
                        <p>Folgende Farben stehen zur Verf√ºgung:</p>
                        <ul>
                            <li>Schwarz (bk), Blau (bl), Dunkelblau (dbl), Dunkelblau-Wei√ü (dblws)</li>
                            <li>Braun (br), Gr√ºn-Gelb (gnge), Rot (rt)</li>
                            <li>Grau (gr), Orange (or), Wei√ü (ws)</li>
                        </ul>
                    </div>
                    
                    <div class="section">
                        <h2>9. Tipps & Best Practices</h2>
                        <ul>
                            <li>Speichern Sie regelm√§√üig Ihre Projekte</li>
                            <li>Verwenden Sie aussagekr√§ftige Namen f√ºr Kabelstr√§nge</li>
                            <li>Organisieren Sie Muster in Gruppen f√ºr bessere √úbersicht</li>
                            <li>Pr√ºfen Sie den Ma√üstab vor dem Zeichnen</li>
                            <li>Bei gro√üen Bildern: Nutzen Sie Zoom und Panning</li>
                            <li>Exportieren Sie Muster f√ºr Wiederverwendung in anderen Projekten</li>
                        </ul>
                    </div>
                </div>
            </body>
            </html>
        `);
        
        helpWindow.document.close();
    }
</script>
</body>
</html>