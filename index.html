<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="UWE - Universal Wiring Engine: Professionelles Tool zur Erfassung und Dokumentation von Kabelb√§umen mit Ma√üstab-Messung und Wustec-Export">
    <meta name="keywords" content="Kabelbaum, Verdrahtung, Kabel, UWE, Wiring, Dokumentation">
    <meta name="author" content="UWE">
    <title>UWE - Universal Wiring Engine</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        
        :root { 
            /* Word 2024 Farbpalette */
            --primary: #0078d4; 
            --primary-dark: #005a9e; 
            --primary-hover: #106ebe;
            --secondary: #323130; 
            --secondary-light: #605e5c;
            --success: #107c10; 
            --danger: #d13438; 
            --warning: #ffaa44; 
            --light: #faf9f8; 
            --card-bg: #ffffff;
            --card-border: #edebe9;
            --ribbon-bg: #faf9f8;
            --ribbon-border: #edebe9;
            --sidebar-bg: #ffffff;
            --text-primary: #323130;
            --text-secondary: #605e5c;
        }
        
        * { box-sizing: border-box; }
        
        body { 
            font-family: 'Segoe UI', 'Inter', -apple-system, BlinkMacSystemFont, sans-serif; 
            display: flex; 
            flex-direction: column;
            height: 100vh; 
            margin: 0; 
            background: #f3f2f1;
            color: var(--text-primary); 
            overflow: hidden;
            position: relative;
        }
        
        /* Top Ribbon Bar - Word 2024 Style */
        #ribbonBar {
            background: var(--ribbon-bg);
            border-bottom: 1px solid var(--ribbon-border);
            padding: 8px 16px;
            display: flex;
            align-items: center;
            gap: 12px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            z-index: 100;
            flex-shrink: 0;
        }
        .ribbon-group {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 4px 12px;
            border-right: 1px solid var(--card-border);
        }
        .ribbon-group:last-child {
            border-right: none;
        }
        .ribbon-group.spacer {
            margin-left: auto;
            margin-right: 240px; /* Platz f√ºr Logo links neben Muster */
        }
        .ribbon-group-title {
            font-size: 11px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            margin-bottom: 4px;
        }
        .ribbon-buttons {
            display: flex;
            gap: 4px;
        }
        .ribbon-btn {
            padding: 6px 12px;
            background: transparent;
            border: 1px solid transparent;
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 13px;
            cursor: pointer;
            transition: all 0.15s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .ribbon-btn:hover {
            background: #edebe9;
            border-color: #c8c6c4;
        }
        .ribbon-btn.primary {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }
        .ribbon-btn.primary:hover {
            background: var(--primary-hover);
        }
        .ribbon-btn.success {
            background: var(--success);
            color: white;
            border-color: var(--success);
        }
        .ribbon-btn.success:hover {
            background: #0e6b0e;
        }
        
        /* Ribbon Pop-up Men√ºs - Word 2024 Style */
        .ribbon-popup {
            position: relative;
            display: inline-block;
        }
        .ribbon-popup-content {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            background: white;
            min-width: 280px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            border: 1px solid var(--card-border);
            border-radius: 2px;
            padding: 16px;
            z-index: 1000;
            margin-top: 4px;
        }
        .ribbon-popup-content.show {
            display: block;
        }
        .ribbon-popup-content label {
            display: block;
            margin-bottom: 8px;
            font-size: 13px;
            font-weight: 500;
            color: var(--text-primary);
        }
        .ribbon-popup-content input[type="file"],
        .ribbon-popup-content input[type="number"] {
            width: 100%;
            margin-bottom: 12px;
        }
        .ribbon-popup-content .hint {
            font-size: 11px;
            color: var(--text-secondary);
            margin-bottom: 8px;
            font-style: italic;
        }
        .ribbon-popup-content .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 12px;
        }
        .ribbon-popup-content .checkbox-group input[type="checkbox"] {
            width: auto;
            margin: 0;
        }
        .ribbon-popup-content .checkbox-group label {
            margin: 0;
            font-weight: 400;
            cursor: pointer;
        }
        .ribbon-popup-content button {
            width: 100%;
            margin-top: 8px;
        }
        
        /* Logo oben rechts neben dem Hilfe-Button */
        #logoContainer {
            position: fixed;
            top: 12px;
            right: 60px;
            z-index: 1001;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        #logoContainer .logo-hundt {
            font-size: 32px;
            font-weight: bold;
            color: #0078d4;
            font-style: italic;
            line-height: 1;
            letter-spacing: -1px;
        }
        #logoContainer .logo-elektrosysteme {
            font-size: 12px;
            font-weight: normal;
            color: #666666;
            font-style: italic;
            margin-top: 2px;
            letter-spacing: 0.5px;
        }
        
        /* Hilfe-Button oben rechts */
        #helpButton {
            position: fixed;
            top: 12px;
            right: 16px;
            z-index: 1001;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: var(--primary);
            color: white;
            border: none;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #helpButton:hover {
            background: var(--primary-hover);
            transform: scale(1.05);
        }
        
        /* Main Container - Flex Layout */
        #appContainer {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        
        /* Linke Sidebar - Kabelstrang-Erstellung */
        #sidebar { 
            width: 320px; 
            padding: 16px; 
            background: var(--sidebar-bg);
            border-right: 1px solid var(--card-border); 
            overflow-y: auto; 
            flex-shrink: 0; 
            display: flex; 
            flex-direction: column; 
            gap: 16px;
        }
        
        /* Rechte Sidebar - Muster & Archiv */
        #patternSidebar { 
            width: 320px; 
            padding: 16px; 
            background: var(--sidebar-bg);
            border-left: 1px solid var(--card-border); 
            overflow-y: auto; 
            flex-shrink: 0; 
            display: flex; 
            flex-direction: column; 
            gap: 16px;
        }
        
        #sidebar::-webkit-scrollbar, #patternSidebar::-webkit-scrollbar { 
            width: 8px; 
        }
        #sidebar::-webkit-scrollbar-track, #patternSidebar::-webkit-scrollbar-track { 
            background: #f3f2f1; 
        }
        #sidebar::-webkit-scrollbar-thumb, #patternSidebar::-webkit-scrollbar-thumb { 
            background: #c8c6c4; 
            border-radius: 4px; 
        }
        #sidebar::-webkit-scrollbar-thumb:hover, #patternSidebar::-webkit-scrollbar-thumb:hover { 
            background: #a19f9d; 
        }
        
        /* Titel Branding - Word 2024 Style */
        .brand-container { 
            margin-bottom: 12px; 
            padding-bottom: 12px; 
            border-bottom: 1px solid var(--card-border); 
        }
        .brand-letter { 
            font-size: 1.8em; 
            font-weight: 600; 
            color: var(--primary);
            display: inline-block;
        }
        .brand-suffix { 
            font-size: 0.9em; 
            color: var(--text-secondary); 
            font-weight: 400; 
            margin-right: 8px; 
        }
        .brand-title {
            font-size: 1.1em;
            font-weight: 600;
            color: var(--text-primary);
        }
        .brand-subtitle {
            font-size: 0.85em;
            color: var(--text-secondary);
        }

        /* Step Cards - Word 2024 Style */
        .step { 
            background: var(--card-bg);
            padding: 16px; 
            border-radius: 4px; 
            border: 1px solid var(--card-border);
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
            transition: all 0.15s ease;
        }
        .step:hover {
            border-color: var(--primary);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .step strong {
            display: block;
            font-size: 0.9em;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 10px;
        }
        
        #main { 
            flex-grow: 1; 
            background: #f3f2f1; 
            display: flex; 
            justify-content: center; 
            align-items: center;
            position: relative; 
            overflow: auto; 
        }
        canvas { 
            background: white; 
            cursor: crosshair; 
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            border: 1px solid var(--card-border);
            max-width: 100%; 
            max-height: 100%; 
            object-fit: contain; 
        }

        /* Modal - Word 2024 Style */
        #overlay { 
            display: none; 
            position: fixed; 
            top:0; 
            left:0; 
            width:100%; 
            height:100%; 
            background: rgba(0,0,0,0.4);
            z-index: 999; 
        }
        #modal { 
            display: none; 
            position: fixed; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%); 
            width: 90%; 
            max-width: 1100px; 
            background: white; 
            color: var(--text-primary); 
            padding: 24px; 
            border-radius: 4px; 
            box-shadow: 0 8px 32px rgba(0,0,0,0.2); 
            z-index: 1000; 
            max-height: 90vh; 
            overflow-y: auto;
            border: 1px solid var(--card-border);
        }
        #modal::-webkit-scrollbar { width: 10px; }
        #modal::-webkit-scrollbar-track { background: #f1f5f9; border-radius: 5px; }
        #modal::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 5px; }
        #modal::-webkit-scrollbar-thumb:hover { background: #94a3b8; }
        
        table { 
            width: 100%; 
            border-collapse: collapse; 
            margin-top: 20px; 
            background: white; 
            border-radius: 8px;
            overflow: hidden;
        }
        th, td { 
            border: 1px solid #e2e8f0; 
            padding: 12px; 
            text-align: left; 
            font-size: 14px; 
            color: #334155; 
        }
        th { 
            background: #faf9f8;
            font-weight: 600;
            color: var(--text-primary);
            border-bottom: 2px solid var(--card-border);
        }
        tr:hover { background: #faf9f8; }
        
        input[type="text"], input[type="number"], select { 
            width: 100%; 
            padding: 6px 10px; 
            box-sizing: border-box; 
            border: 1px solid var(--card-border); 
            border-radius: 2px; 
            font-size: 14px;
            font-family: 'Segoe UI', sans-serif;
            transition: all 0.15s ease;
            background: white;
            color: var(--text-primary);
        }
        input[type="text"]:focus, input[type="number"]:focus, select:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 1px var(--primary);
        }
        input[type="color"] {
            height: 36px;
            border: 1px solid var(--card-border);
            border-radius: 2px;
            cursor: pointer;
            transition: all 0.15s ease;
        }
        input[type="color"]:hover {
            border-color: var(--primary);
        }
        input[type="file"] {
            padding: 8px;
            border: 1px dashed var(--card-border);
            border-radius: 2px;
            background: white;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.15s ease;
            width: 100%;
            font-size: 13px;
        }
        input[type="file"]:hover {
            border-color: var(--primary);
            background: #faf9f8;
        }
        input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: var(--primary);
        }
        
        /* Buttons - Modern Design */
        .fill-btn { 
            background: var(--primary); 
            color: white; 
            border: none; 
            border-radius: 2px; 
            padding: 2px 8px; 
            font-size: 11px; 
            cursor: pointer; 
            float: right; 
            margin-top: 2px;
            font-weight: 400;
            transition: all 0.15s ease;
        }
        .fill-btn:hover {
            background: var(--primary-hover);
        }
        
        button { 
            padding: 8px 16px; 
            border-radius: 2px; 
            border: 1px solid var(--card-border); 
            font-weight: 400; 
            cursor: pointer; 
            transition: all 0.15s ease;
            font-family: 'Segoe UI', sans-serif;
            font-size: 14px;
            background: white;
            color: var(--text-primary);
        }
        button:hover {
            background: #f3f2f1;
            border-color: var(--primary);
        }
        button:active {
            background: #edebe9;
        }
        .btn-primary { 
            background: var(--primary);
            color: white; 
            border-color: var(--primary);
            width: 100%;
        }
        .btn-primary:hover {
            background: var(--primary-hover);
            border-color: var(--primary-hover);
        }
        .btn-success { 
            background: var(--success);
            color: white; 
            border-color: var(--success);
            width: 100%;
        }
        .btn-success:hover {
            background: #0e6b0e;
            border-color: #0e6b0e;
        }
        .btn-danger { 
            background: var(--danger);
            color: white; 
            border-color: var(--danger);
            width: 100%;
        }
        .btn-danger:hover {
            background: #b02a2e;
            border-color: #b02a2e;
        }
        
        /* Liste in Sidebar - Word 2024 Style */
        .bundle-item { 
            background: var(--card-bg);
            padding: 12px; 
            border-radius: 2px; 
            margin-top: 6px; 
            display: flex; 
            align-items: center; 
            justify-content: space-between; 
            font-size: 0.9em;
            border: 1px solid var(--card-border);
            transition: all 0.15s ease;
        }
        .bundle-item:hover {
            background: #faf9f8;
            border-color: var(--primary);
        }
        .bundle-info { 
            display: flex; 
            align-items: center; 
            gap: 12px; 
        }
        .bundle-actions { 
            display: flex; 
            align-items: center; 
            gap: 6px; 
        }
        .action-btn { 
            padding: 4px 8px; 
            font-size: 13px; 
            background: white;
            color: var(--text-primary); 
            border-radius: 2px; 
            cursor: pointer; 
            width: 28px; 
            height: 28px; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            border: 1px solid var(--card-border);
            transition: all 0.15s ease;
        }
        .action-btn:hover {
            background: #f3f2f1;
            border-color: var(--primary);
        }
        .color-dot { 
            width: 16px; 
            height: 16px; 
            border-radius: 50%; 
            border: 1px solid var(--card-border);
            cursor: pointer;
            transition: all 0.15s ease;
        }
        .color-dot:hover {
            transform: scale(1.15);
            border-color: var(--primary);
        }
        
        /* Label Styling */
        label {
            font-weight: 400;
            color: var(--text-primary);
            font-size: 0.9em;
            margin-bottom: 6px;
            display: block;
        }
        
        /* Hint Text */
        #drawHint {
            color: var(--text-secondary);
            font-size: 0.85em;
        }
        
        /* Project List Header */
        #project-list strong {
            font-size: 0.95em;
            font-weight: 600;
            color: var(--text-primary);
        }
    </style>
    <!-- jsPDF f√ºr PDF-Export -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
</head>
<body>

<!-- Top Ribbon Bar - Word 2024 Style -->
<div id="ribbonBar">
    <div class="ribbon-group">
        <div style="display: flex; flex-direction: column;">
            <div class="ribbon-group-title">Bild</div>
            <div class="ribbon-buttons">
                <div class="ribbon-popup">
                    <button class="ribbon-btn" onclick="toggleImagePopup()" title="Bild laden">
                        üñºÔ∏è Bild laden
                    </button>
                    <div id="imagePopup" class="ribbon-popup-content">
                        <label>Bild ausw√§hlen:</label>
                        <input type="file" id="upload" accept="image/*">
                        <div class="checkbox-group">
                            <input type="checkbox" id="autoFitCheckbox" checked onchange="toggleAutoFit()">
                            <label for="autoFitCheckbox">Bild automatisch an Fenster anpassen</label>
                        </div>
                        <div id="imageStatus" style="font-size: 12px; color: var(--text-secondary); margin-top: 8px;">Keine Datei ausgew√§hlt</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="ribbon-group">
        <div style="display: flex; flex-direction: column;">
            <div class="ribbon-group-title">Ma√üstab</div>
            <div class="ribbon-buttons">
                <div class="ribbon-popup">
                    <button class="ribbon-btn" onclick="toggleScalePopup()" title="Ma√üstab festlegen">
                        üìè Ma√üstab
                    </button>
                    <div id="scalePopup" class="ribbon-popup-content">
                        <div class="hint">(Eingabe in mm)</div>
                        <label>L√§nge in mm:</label>
                        <input type="number" id="realLength" placeholder="L√§nge in mm" value="0">
                        <button class="btn-primary" onclick="setMode('scale')" id="btnScale">Ma√üstab festlegen</button>
                        <button class="btn-success" id="btnConfirmScale" onclick="confirmScale()" style="display:none; margin-top:8px;">Ma√üstab best√§tigen ‚úì</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="ribbon-group">
        <div style="display: flex; flex-direction: column;">
            <div class="ribbon-group-title">Datei</div>
            <div class="ribbon-buttons">
                <button class="ribbon-btn primary" onclick="saveProjectJSON()" title="Projekt speichern">
                    üíæ Speichern
                </button>
                <button class="ribbon-btn" onclick="document.getElementById('loadProject').click()" title="Projekt laden">
                    üìÇ Laden
                </button>
                <input type="file" id="loadProject" style="display:none" accept=".json" onchange="loadProjectJSON(event)">
            </div>
        </div>
    </div>
    
    <div class="ribbon-group">
        <div style="display: flex; flex-direction: column;">
            <div class="ribbon-group-title">Export</div>
            <div class="ribbon-buttons">
                <button class="ribbon-btn success" onclick="exportWustec()" title="Wustec CSV Export">
                    üìä Wustec (.csv)
                </button>
                <button class="ribbon-btn" onclick="exportVisual()" title="Bild & Legende Export">
                    üñºÔ∏è Bild & Legende
                </button>
            </div>
        </div>
    </div>
    
    <div class="ribbon-group spacer">
        <div style="display: flex; flex-direction: column;">
            <div class="ribbon-group-title">Muster</div>
            <div class="ribbon-buttons">
                <button class="ribbon-btn" onclick="exportPatterns()" title="Muster exportieren">
                    üì§ Export
                </button>
                <button class="ribbon-btn" onclick="document.getElementById('importPatterns').click()" title="Muster importieren">
                    üì• Import
                </button>
                <input type="file" id="importPatterns" style="display:none" accept=".json" onchange="importPatterns(event)">
            </div>
        </div>
    </div>
</div>

<!-- Logo oben links -->
<div id="logoContainer">
    <div class="logo-hundt">HUNDT</div>
    <div class="logo-elektrosysteme">ELEKTROSYSTEME</div>
</div>

<!-- Hilfe-Button oben rechts -->
<button id="helpButton" onclick="openHelpWindow()" title="Anleitung √∂ffnen">?</button>

<!-- Main Container -->
<div id="appContainer">
    <!-- Linke Sidebar - Kabelstrang-Erstellung -->
    <div id="sidebar">
        <div class="brand-container">
            <span class="brand-letter">U</span><span class="brand-suffix">niversal</span>
            <span class="brand-letter">W</span><span class="brand-suffix">iring</span>
            <span class="brand-letter">E</span><span class="brand-suffix">ngine</span>
        </div>
    
    <div class="step">
        <strong>3. Farbe & Messen</strong>
        <input type="color" id="drawColor" value="#f39c12" style="height: 40px; width: 100%; cursor: pointer; border:none; border-radius:4px;">
        <button class="btn-primary" onclick="setMode('measure')" id="btnMeasure" disabled style="background: var(--warning); margin-top:10px;">Kabelstrang zeichnen</button>
        <div id="drawHint" style="display:none; font-size: 0.8em; color: #bdc3c7; margin-top: 5px; font-style: italic;">üí° Tipp: Doppelklick beendet das Zeichnen</div>
    </div>

        <div id="project-list">
            <strong>Erfasste Str√§nge:</strong>
            <div id="bundleContainer" style="margin-top:10px;"></div>
        </div>
    </div>

    <!-- Hauptbereich - Canvas -->
    <div id="main"><canvas id="canvas"></canvas></div>

    <!-- Rechte Sidebar - Muster & Archiv -->
    <div id="patternSidebar">
        <div class="brand-container">
            <div class="brand-letter">M</div>
            <div class="brand-text">
                <div class="brand-title">Muster</div>
                <div class="brand-subtitle">Kabelstr√§nge</div>
            </div>
        </div>
        
        <div class="step">
            <div style="display: flex; align-items: center; justify-content: space-between; cursor: pointer; user-select: none; padding: 5px 0;" onclick="togglePatternManagement()">
                <h3 style="margin: 0; font-size: 0.95em; font-weight: 600;">Muster-Verwaltung</h3>
                <span id="patternManagementToggle" style="font-size: 1em; transition: transform 0.2s;">‚ñº</span>
            </div>
            <div id="patternManagementContent" style="margin-top: 12px;">
                <button class="btn-primary" onclick="openPatternModal()" style="margin-bottom: 8px; font-size: 13px;">+ Neues Muster</button>
                <button class="btn-primary" onclick="createPatternGroup()" style="margin-bottom: 8px; background: var(--secondary); font-size: 13px;">+ Neue Gruppe</button>
                <button class="btn-danger" onclick="deletePatternGroupFromList()" style="margin-bottom: 8px; font-size: 13px;">Gruppe l√∂schen</button>
            </div>
        </div>
    
        <div class="step">
            <h3 style="margin-top: 0; font-size: 0.95em; font-weight: 600;" id="patternListTitle">Muster-Liste</h3>
            <div id="patternContainer" style="max-height: 500px; overflow-y: auto;">
                <!-- Muster werden hier dynamisch eingef√ºgt -->
            </div>
        </div>
    </div>
</div>

<div id="overlay" onclick="closeModal()"></div>
<div id="modal">
    <div style="display:flex; justify-content:space-between; align-items:center; border-bottom:2px solid #eee; margin-bottom:15px;">
        <h3 id="modalHeaderTitle" style="margin:0">Kabelbaum Details</h3>
        <span id="currentLengthDisplay" style="font-weight:bold; color:var(--success); font-size:1.2em;"></span>
    </div>
    <div style="display:grid; grid-template-columns: 1fr 1fr 1fr; gap:15px; margin-bottom:15px;">
        <div><label>Strang Name:</label><input type="text" id="bundleName"></div>
        <div><label>Zuschlag Vorn (mm):</label><input type="number" id="plusStart" value="150"></div>
        <div><label>Zuschlag Hinten (mm):</label><input type="number" id="plusEnd" value="150"></div>
    </div>
    <div id="patternGroupSelector" style="display:none; margin-bottom:15px;">
        <label>Gruppe:</label>
        <select id="patternGroupSelect" style="width:100%; padding:8px; border-radius:6px; background:var(--input-bg); color:var(--text-light); border:1px solid var(--card-border);">
            <!-- Wird dynamisch gef√ºllt -->
        </select>
    </div>
    <div style="background:#f8f9fa; padding:10px; border-radius:5px; margin-bottom:10px; display:flex; gap:10px; align-items:center;">
        <label>Adern:</label>
        <input type="number" id="wireCount" value="1" min="1" style="width:70px;">
        <button onclick="updateWireTable()" style="padding:6px 12px; background:var(--secondary); color:white;">Tabelle erzeugen</button>
    </div>
    <table id="wireTable">
        <thead>
            <tr>
                <th style="width:40px;">#</th>
                <th>Typ <button class="fill-btn" onclick="autoFill('wire-type', false)">‚ñº</button></th>
                <th>Farbe <button class="fill-btn" onclick="autoFill('wire-color', false)">‚ñº</button></th>
                <th>mm¬≤ <button class="fill-btn" onclick="autoFill('wire-cross', false)">‚ñº</button></th>
                <th>Quelle <button class="fill-btn" onclick="autoFill('wire-label-s', true)">‚ñº+</button></th>
                <th>Ziel <button class="fill-btn" onclick="autoFill('wire-label-e', true)">‚ñº+</button></th>
            </tr>
        </thead>
        <tbody></tbody>
    </table>
    <div style="margin-top:20px; display:flex; justify-content:space-between; align-items:center; gap:10px;">
        <div style="display:flex; gap:10px;">
            <button onclick="addWireRows()" style="padding:8px 16px; background:var(--primary); color:white; border:none; border-radius:4px; cursor:pointer;">Neue Zeilen hinzuf√ºgen</button>
            <button onclick="removeLastWireRow()" style="padding:8px 16px; background:var(--warning); color:black; border:none; border-radius:4px; cursor:pointer;">Letzte Zeile l√∂schen</button>
        </div>
        <div style="display:flex; gap:10px;">
            <button onclick="closeModal()">Abbrechen</button>
            <button class="btn-success" onclick="saveCableBundle()" style="width:220px;">Speichern</button>
        </div>
    </div>
</div>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let img = new Image(), mode = 'none', mmPerPixel = 0, currentPath = [], snapshot, allBundles = [], lastMeasuredLength = 0, mouseX = 0, mouseY = 0;
    let originalImageSnapshot = null, editIndex = -1;
    let zoom = 1, panX = 0, panY = 0, isPanning = false, lastPanPoint = { x: 0, y: 0 };
    let patternBundles = []; // Array f√ºr neue/importierte Muster-Kabelstr√§nge
    let defaultPatternBundles = []; // Array f√ºr Standard-Muster-Kabelstr√§nge (immer vorhanden)
    let selectedPatternIndex = -1; // Index des ausgew√§hlten Musters
    let isPatternMode = false; // Ob ein Muster ausgew√§hlt wurde
    let patternListName = ''; // Name der Muster-Liste (Dateiname)
    let isDefaultPatternList = false; // Markiert, ob die aktuelle Liste Standard-Muster enth√§lt
    let patternGroups = []; // Array f√ºr neue Muster-Gruppen [{id: string, name: string, collapsed: boolean}]
    let defaultPatternGroups = []; // Array f√ºr Standard-Muster-Gruppen [{id: string, name: string, collapsed: boolean}]
    let collapsedGroups = {}; // Objekte f√ºr auf-/zuklappbare Gruppen {groupId: boolean}
    let defaultPatternListCollapsed = true; // Ob die Standard-Muster-Liste zugeklappt ist (beim Start immer geschlossen)
    let patternManagementCollapsed = true; // Ob die Muster-Verwaltung zugeklappt ist (beim Start immer geschlossen)
    let autoFitToWindow = true; // Automatische Bildskalierung auf Fenstergr√∂√üe
    let imageScale = 1, imageOffsetX = 0, imageOffsetY = 0; // F√ºr Bild-Skalierung

    // Pop-up Men√º Funktionen
    function toggleImagePopup() {
        const popup = document.getElementById('imagePopup');
        const scalePopup = document.getElementById('scalePopup');
        if (scalePopup) scalePopup.classList.remove('show');
        if (popup) popup.classList.toggle('show');
    }
    
    function toggleScalePopup() {
        const popup = document.getElementById('scalePopup');
        const imagePopup = document.getElementById('imagePopup');
        if (imagePopup) imagePopup.classList.remove('show');
        if (popup) {
            // Wenn Popup bereits offen ist und der Button erneut geklickt wird, schlie√üe es nur wenn Ma√üstab bereits best√§tigt wurde
            if (popup.classList.contains('show')) {
                // Pr√ºfe ob Ma√üstab bereits best√§tigt wurde (Button ist versteckt)
                const confirmBtn = document.getElementById('btnConfirmScale');
                if (confirmBtn && confirmBtn.style.display === 'none') {
                    // Ma√üstab wurde bereits best√§tigt, Popup kann geschlossen werden
                    popup.classList.remove('show');
                }
                // Wenn Ma√üstab noch nicht best√§tigt wurde, bleibt das Popup offen
            } else {
                // Popup √∂ffnen
                popup.classList.add('show');
            }
        }
    }
    
    // Schlie√üe Pop-ups beim Klicken au√üerhalb
    document.addEventListener('click', function(event) {
        const imagePopup = document.getElementById('imagePopup');
        const scalePopup = document.getElementById('scalePopup');
        const isImagePopup = event.target.closest('#imagePopup');
        const isScalePopup = event.target.closest('#scalePopup');
        const isImageBtn = event.target.closest('.ribbon-popup');
        const isScaleBtn = event.target.closest('button[onclick*="toggleScalePopup"]');
        
        if (imagePopup && !isImagePopup && !isImageBtn) {
            imagePopup.classList.remove('show');
        }
        // Ma√üstab-Popup NICHT schlie√üen beim Klicken au√üerhalb - bleibt offen bis "Ma√üstab best√§tigen" gedr√ºckt wird
        // Nur schlie√üen, wenn der Toggle-Button erneut geklickt wird
        if (scalePopup && !isScalePopup && !isImageBtn && !isScaleBtn && scalePopup.classList.contains('show')) {
            // Pr√ºfe ob der Klick auf den Canvas ist (dann nicht schlie√üen, da der Benutzer Punkte setzen m√∂chte)
            const canvas = document.getElementById('canvas');
            const isCanvasClick = event.target === canvas || canvas.contains(event.target);
            if (!isCanvasClick) {
                // Nur schlie√üen, wenn nicht auf Canvas geklickt wurde
                // Aber eigentlich soll es offen bleiben, also kommentieren wir das aus
                // scalePopup.classList.remove('show');
            }
        }
    });

    document.getElementById('upload').onchange = (e) => {
        loadMainImage(e.target.files[0]);
        // Update Status
        const status = document.getElementById('imageStatus');
        if (status && e.target.files[0]) {
            status.textContent = 'Ausgew√§hlt: ' + e.target.files[0].name;
            status.style.color = 'var(--success)';
        }
    };

    function resizeCanvas() {
        const main = document.getElementById('main');
        canvas.width = main.clientWidth;
        canvas.height = main.clientHeight;
        if (img.complete && img.width > 0 && autoFitToWindow) {
            calculateImageScale();
            rebuildDrawing();
        }
    }
    
    function calculateImageScale() {
        if (!img.complete || img.width === 0) return;
        const main = document.getElementById('main');
        const availableWidth = main.clientWidth;
        const availableHeight = main.clientHeight;
        
        // Berechne Skalierung, damit das Bild vollst√§ndig sichtbar ist
        const scaleX = availableWidth / img.width;
        const scaleY = availableHeight / img.height;
        imageScale = Math.min(scaleX, scaleY) * 0.95; // 95% f√ºr etwas Rand
        
        // Zentriere das Bild - in Canvas-Koordinaten
        const scaledWidth = img.width * imageScale;
        const scaledHeight = img.height * imageScale;
        imageOffsetX = (availableWidth - scaledWidth) / 2;
        imageOffsetY = (availableHeight - scaledHeight) / 2;
    }
    
    function toggleAutoFit() {
        autoFitToWindow = document.getElementById('autoFitCheckbox').checked;
        if (img.complete && img.width > 0) {
            if (autoFitToWindow) {
                resizeCanvas();
            } else {
                // Zur√ºck zur Original-Bildgr√∂√üe
                canvas.width = img.width;
                canvas.height = img.height;
                imageScale = 1;
                imageOffsetX = 0;
                imageOffsetY = 0;
                zoom = 1;
                panX = 0;
                panY = 0;
                rebuildDrawing();
            }
        }
    }

    function loadMainImage(file) {
        if (!file) return;
        const reader = new FileReader();
        reader.onerror = () => alert("Fehler beim Laden des Bildes!");
        reader.onload = (f) => {
            img.onload = () => {
                if (autoFitToWindow) {
                    resizeCanvas();
                } else {
                    canvas.width = img.width; 
                    canvas.height = img.height;
                    imageScale = 1;
                    imageOffsetX = 0;
                    imageOffsetY = 0;
                }
                // Reset Zoom und Pan beim Laden eines neuen Bildes
                zoom = 1;
                panX = 0;
                panY = 0;
                originalImageSnapshot = ctx.getImageData(0,0,canvas.width, canvas.height);
                rebuildDrawing();
            };
            img.onerror = () => alert("Fehler: Bild konnte nicht geladen werden!");
            img.src = f.target.result;
        };
        reader.readAsDataURL(file);
    }

    // Canvas-Gr√∂√üe bei Fenster-Resize anpassen (nur wenn autoFitToWindow aktiv)
    window.addEventListener('resize', () => {
        if (img.complete && img.width > 0 && autoFitToWindow) {
            resizeCanvas();
        }
    });

    function setMode(m) { 
        mode = m; 
        currentPath = []; 
        // Muster-Modus zur√ºcksetzen, wenn normaler Zeichnen-Modus gestartet wird
        if (m === 'measure' && !isPatternMode) {
            isPatternMode = false;
            selectedPatternIndex = -1;
        }
        if(m === 'measure' && editIndex === -1 && !isPatternMode) {
            document.getElementById('btnMeasure').style.background = 'var(--warning)';
            document.getElementById('btnMeasure').textContent = 'Kabelstrang zeichnen';
            document.getElementById('drawHint').style.display = 'block';
        } else {
            document.getElementById('drawHint').style.display = 'none';
        }
        // Snapshot aktualisieren, damit Zeichnen funktioniert
        rebuildDrawing();
    }
    function getPos(e) {
        const rect = canvas.getBoundingClientRect();
        // WICHTIG: Umrechnung von Anzeige-Koordinaten zu Canvas-Pixel-Koordinaten
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        
        const canvasX = (e.clientX - rect.left) * scaleX;
        const canvasY = (e.clientY - rect.top) * scaleY;
        
        // Verwende die Canvas-Transformationsmatrix direkt f√ºr pr√§zise Umkehrung
        ctx.save();
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.translate(panX * zoom, panY * zoom);
        ctx.scale(zoom, zoom);
        if (autoFitToWindow) {
            ctx.translate(imageOffsetX / zoom, imageOffsetY / zoom);
            ctx.scale(imageScale, imageScale);
        }
        
        // Hole die Transformationsmatrix
        const matrix = ctx.getTransform();
        ctx.restore();
        
        // Berechne die inverse Transformation
        const det = matrix.a * matrix.d - matrix.b * matrix.c;
        if (Math.abs(det) < 0.0001) {
            // Fallback: direkte Berechnung
            if (autoFitToWindow) {
                return {
                    x: (canvasX - imageOffsetX - panX * zoom) / (imageScale * zoom),
                    y: (canvasY - imageOffsetY - panY * zoom) / (imageScale * zoom)
                };
            } else {
                return {
                    x: canvasX / zoom - panX,
                    y: canvasY / zoom - panY
                };
            }
        }
        
        // Inverse Transformation mit Matrix
        const x = (matrix.d * (canvasX - matrix.e) - matrix.c * (canvasY - matrix.f)) / det;
        const y = (matrix.a * (canvasY - matrix.f) - matrix.b * (canvasX - matrix.e)) / det;
        
        return { x, y };
    }

    canvas.onmousemove = (e) => {
        if (isPanning) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const deltaX = ((e.clientX - rect.left) - lastPanPoint.x) * scaleX;
            const deltaY = ((e.clientY - rect.top) - lastPanPoint.y) * scaleY;
            panX += deltaX / zoom;
            panY += deltaY / zoom;
            lastPanPoint = { x: e.clientX - rect.left, y: e.clientY - rect.top };
            rebuildDrawing();
            return;
        }
        const pos = getPos(e); mouseX = pos.x; mouseY = pos.y;
        if (mode !== 'none' && currentPath.length > 0) redrawCanvas();
    };

    function redrawCanvas() {
        ctx.save();
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.restore();
        
        ctx.save();
        // Transformationen
        ctx.translate(panX * zoom, panY * zoom);
        ctx.scale(zoom, zoom);
        
        if (autoFitToWindow) {
            // Mit Bildskalierung
            ctx.translate(imageOffsetX / zoom, imageOffsetY / zoom);
            ctx.scale(imageScale, imageScale);
        }
        
        // Zeichne das Basisbild
        if(img.complete && img.width > 0) {
            ctx.drawImage(img, 0, 0);
        }
        
        // Zeichne alle Str√§nge (in Bild-Koordinaten)
        allBundles.forEach(b => {
            if (!b.path || b.path.length === 0) return;
            ctx.strokeStyle = b.color;
            const lineWidth = autoFitToWindow ? 
                Math.max(4, canvas.width / 500) / (zoom * imageScale) : 
                Math.max(4, canvas.width / 500) / zoom;
            ctx.lineWidth = lineWidth;
            ctx.beginPath();
            ctx.moveTo(b.path[0].x, b.path[0].y);
            b.path.forEach(p => ctx.lineTo(p.x, p.y));
            ctx.stroke();
        });
        
        // Zeichne aktuellen Pfad (in Bild-Koordinaten)
        const lineWidth = autoFitToWindow ? 
            Math.max(4, canvas.width / 500) / (zoom * imageScale) : 
            Math.max(4, canvas.width / 500) / zoom;
        ctx.lineWidth = lineWidth;
        ctx.strokeStyle = (mode === 'scale') ? 'red' : document.getElementById('drawColor').value;
        if (currentPath.length > 0) {
            ctx.beginPath(); 
            ctx.moveTo(currentPath[0].x, currentPath[0].y);
            currentPath.forEach(p => ctx.lineTo(p.x, p.y));
            ctx.lineTo(mouseX, mouseY); 
            ctx.stroke();
        }
        ctx.restore();
    }

    canvas.onclick = (e) => {
        if (e.button === 1) return; // Ignoriere mittlere Maustaste
        if (mode === 'none') return;
        currentPath.push(getPos(e));
        // Aktualisiere nur den Snapshot, ohne alles neu zu zeichnen
        // Das verhindert, dass die Zeichnung springt
        updateSnapshot();
        if (mode === 'scale' && currentPath.length === 2) {
            document.getElementById('btnConfirmScale').style.display = 'block';
            mode = 'none';
        }
    };
    
    function updateSnapshot() {
        // Zeichne alles neu, um einen aktuellen Snapshot zu erstellen
        ctx.save();
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.restore();
        
        ctx.save();
        // Transformationen
        ctx.translate(panX * zoom, panY * zoom);
        ctx.scale(zoom, zoom);
        
        if (autoFitToWindow) {
            ctx.translate(imageOffsetX / zoom, imageOffsetY / zoom);
            ctx.scale(imageScale, imageScale);
        }
        
        // Zeichne das Basisbild
        if(img.complete && img.width > 0) {
            ctx.drawImage(img, 0, 0);
        }
        
        // Zeichne alle gespeicherten Str√§nge (in Bild-Koordinaten)
        allBundles.forEach(b => {
            if (!b.path || b.path.length === 0) return;
            ctx.strokeStyle = b.color;
            const lineWidth = autoFitToWindow ? 
                Math.max(4, canvas.width / 500) / (zoom * imageScale) : 
                Math.max(4, canvas.width / 500) / zoom;
            ctx.lineWidth = lineWidth;
            ctx.beginPath();
            ctx.moveTo(b.path[0].x, b.path[0].y);
            b.path.forEach(p => ctx.lineTo(p.x, p.y));
            ctx.stroke();
        });
        
        // Zeichne bereits gesetzte Punkte des aktuellen Pfads (ohne Mauszeiger)
        if (currentPath.length > 0) {
            const lineWidth = autoFitToWindow ? 
                Math.max(4, canvas.width / 500) / (zoom * imageScale) : 
                Math.max(4, canvas.width / 500) / zoom;
            ctx.lineWidth = lineWidth;
            ctx.strokeStyle = (mode === 'scale') ? 'red' : document.getElementById('drawColor').value;
            ctx.beginPath();
            ctx.moveTo(currentPath[0].x, currentPath[0].y);
            for (let i = 1; i < currentPath.length; i++) {
                ctx.lineTo(currentPath[i].x, currentPath[i].y);
            }
            ctx.stroke();
        }
        ctx.restore();
        
        // Snapshot erstellen
        snapshot = ctx.getImageData(0,0,canvas.width, canvas.height);
    }
    
    // Mausrad-Zoom
    canvas.onwheel = (e) => {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        const mouseCanvasX = (e.clientX - rect.left) * scaleX;
        const mouseCanvasY = (e.clientY - rect.top) * scaleY;
        
        const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
        const newZoom = Math.max(0.1, Math.min(5, zoom * zoomFactor));
        
        // Berechne den Punkt unter dem Mauszeiger in Bild-Koordinaten (vor dem Zoom)
        let imagePointX, imagePointY;
        if (autoFitToWindow) {
            imagePointX = (mouseCanvasX - imageOffsetX - panX * zoom) / (imageScale * zoom);
            imagePointY = (mouseCanvasY - imageOffsetY - panY * zoom) / (imageScale * zoom);
        } else {
            imagePointX = mouseCanvasX / zoom - panX;
            imagePointY = mouseCanvasY / zoom - panY;
        }
        
        // Setze den Zoom
        zoom = newZoom;
        
        // Berechne panX und panY neu, damit der gleiche Bildpunkt unter dem Mauszeiger bleibt
        if (autoFitToWindow) {
            // Mit Bildskalierung: Stelle sicher, dass imagePointX/Y unter mouseCanvasX/Y bleibt
            panX = (mouseCanvasX - imageOffsetX - imagePointX * imageScale * zoom) / zoom;
            panY = (mouseCanvasY - imageOffsetY - imagePointY * imageScale * zoom) / zoom;
        } else {
            // Ohne Bildskalierung
            panX = mouseCanvasX / zoom - imagePointX;
            panY = mouseCanvasY / zoom - imagePointY;
        }
        
        rebuildDrawing();
    };
    
    // Mittlere Maustaste f√ºr Panning
    canvas.onmousedown = (e) => {
        if (e.button === 1) { // Mittlere Maustaste
            e.preventDefault();
            isPanning = true;
            const rect = canvas.getBoundingClientRect();
            lastPanPoint = { x: e.clientX - rect.left, y: e.clientY - rect.top };
            canvas.style.cursor = 'grabbing';
        }
    };
    
    canvas.onmouseup = (e) => {
        if (e.button === 1) {
            isPanning = false;
            canvas.style.cursor = 'crosshair';
        }
    };
    
    canvas.onmouseleave = () => {
        isPanning = false;
        canvas.style.cursor = 'crosshair';
    };
    
    // Verhindere Standard-Scroll-Verhalten bei mittlerer Maustaste
    canvas.oncontextmenu = (e) => {
        if (e.button === 1) e.preventDefault();
    };

    function confirmScale() {
        if (currentPath.length < 2) {
            alert("Bitte zuerst zwei Punkte f√ºr den Ma√üstab setzen!");
            return;
        }
        const realLength = parseFloat(document.getElementById('realLength').value);
        if (!realLength || realLength <= 0) {
            alert("Bitte eine g√ºltige L√§nge in mm eingeben!");
            return;
        }
        const d = Math.sqrt(Math.pow(currentPath[1].x-currentPath[0].x,2)+Math.pow(currentPath[1].y-currentPath[0].y,2));
        if (d === 0) {
            alert("Die beiden Punkte sind identisch! Bitte zwei verschiedene Punkte w√§hlen.");
            return;
        }
        mmPerPixel = realLength / d;
        document.getElementById('btnMeasure').disabled = false;
        document.getElementById('btnConfirmScale').style.display = 'none';
        
        // Schlie√üe das Ma√üstab-Popup nach erfolgreicher Best√§tigung
        const scalePopup = document.getElementById('scalePopup');
        if (scalePopup) {
            scalePopup.classList.remove('show');
        }
        
        rebuildDrawing();
    }

    function rebuildDrawing() {
        if(!img.complete || img.width === 0) return;
        ctx.save();
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.restore();
        
        ctx.save();
        // Transformationen (gleiche wie in redrawCanvas)
        ctx.translate(panX * zoom, panY * zoom);
        ctx.scale(zoom, zoom);
        
        if (autoFitToWindow) {
            ctx.translate(imageOffsetX / zoom, imageOffsetY / zoom);
            ctx.scale(imageScale, imageScale);
        }
        
        // Bild zeichnen
        ctx.drawImage(img, 0, 0);
        
        // Str√§nge zeichnen (in Bild-Koordinaten)
        allBundles.forEach(b => {
            if (!b.path || b.path.length === 0) return;
            ctx.strokeStyle = b.color;
            const lineWidth = autoFitToWindow ? 
                Math.max(4, canvas.width / 500) / (zoom * imageScale) : 
                Math.max(4, canvas.width / 500) / zoom;
            ctx.lineWidth = lineWidth;
            ctx.beginPath();
            ctx.moveTo(b.path[0].x, b.path[0].y);
            b.path.forEach(p => ctx.lineTo(p.x, p.y));
            ctx.stroke();
        });
        ctx.restore();
        
        // Snapshot ohne Transformation f√ºr aktuellen Pfad
        snapshot = ctx.getImageData(0,0,canvas.width, canvas.height);
    }

    canvas.ondblclick = () => {
        if (mode === 'measure' && currentPath.length > 1) {
            let px = 0;
            for(let i=1; i<currentPath.length; i++) px += Math.sqrt(Math.pow(currentPath[i].x-currentPath[i-1].x,2)+Math.pow(currentPath[i].y-currentPath[i-1].y,2));
            lastMeasuredLength = px * mmPerPixel;
            
            // Wenn Muster-Modus aktiv, √∂ffne Modal mit bereits geladenen Muster-Daten
            if (isPatternMode && selectedPatternIndex >= 0) {
                // Daten sind bereits geladen, √∂ffne nur das Modal
                document.getElementById('modal').style.display = 'block';
                document.getElementById('overlay').style.display = 'block';
            } else if(editIndex === -1) {
                openModal();
            } else {
                // Neuzeichnen-Modus: Modal mit bestehenden Daten √∂ffnen
            openModal();
            }
        }
    };

    // Funktion zum Sammeln aller Eingabefelder im Modal
    function getAllInputFields() {
        const fields = {
            header: [],
            table: []
        };
        
        // Basis-Felder
        fields.header.push(document.getElementById('bundleName'));
        fields.header.push(document.getElementById('plusStart'));
        fields.header.push(document.getElementById('plusEnd'));
        
        // Gruppenauswahl (wenn sichtbar)
        const patternGroupSelect = document.getElementById('patternGroupSelect');
        if (patternGroupSelect && patternGroupSelect.offsetParent !== null) {
            fields.header.push(patternGroupSelect);
        }
        
        // Aderanzahl
        fields.header.push(document.getElementById('wireCount'));
        
        // Felder aus der Tabelle (strukturiert nach Zeilen und Spalten)
        const wireTable = document.getElementById('wireTable');
        if (wireTable) {
            const rows = wireTable.querySelectorAll('tbody tr');
            rows.forEach(row => {
                const rowFields = {
                    type: row.querySelector('.wire-type'),
                    color: row.querySelector('.wire-color'),
                    cross: row.querySelector('.wire-cross'),
                    source: row.querySelector('.wire-label-s'),
                    end: row.querySelector('.wire-label-e')
                };
                fields.table.push(rowFields);
            });
        }
        
        return fields;
    }
    
    // Funktion zum Finden des Feldes in derselben Spalte, n√§chste/vorherige Zeile
    function findFieldInSameColumn(currentField, direction) {
        const fields = getAllInputFields();
        const wireTable = document.getElementById('wireTable');
        if (!wireTable) return null;
        
        const rows = wireTable.querySelectorAll('tbody tr');
        let currentRowIndex = -1;
        let currentColumn = null;
        
        // Finde aktuelle Zeile und Spalte
        rows.forEach((row, rowIndex) => {
            const rowFields = {
                type: row.querySelector('.wire-type'),
                color: row.querySelector('.wire-color'),
                cross: row.querySelector('.wire-cross'),
                source: row.querySelector('.wire-label-s'),
                end: row.querySelector('.wire-label-e')
            };
            
            if (rowFields.type === currentField) {
                currentRowIndex = rowIndex;
                currentColumn = 'type';
            } else if (rowFields.color === currentField) {
                currentRowIndex = rowIndex;
                currentColumn = 'color';
            } else if (rowFields.cross === currentField) {
                currentRowIndex = rowIndex;
                currentColumn = 'cross';
            } else if (rowFields.source === currentField) {
                currentRowIndex = rowIndex;
                currentColumn = 'source';
            } else if (rowFields.end === currentField) {
                currentRowIndex = rowIndex;
                currentColumn = 'end';
            }
        });
        
        if (currentRowIndex === -1 || !currentColumn) return null;
        
        // Berechne n√§chste/vorherige Zeile
        let nextRowIndex;
        if (direction === 'down') {
            nextRowIndex = currentRowIndex + 1;
        } else {
            nextRowIndex = currentRowIndex - 1;
        }
        
        // Pr√ºfe ob Zeile existiert
        if (nextRowIndex < 0 || nextRowIndex >= rows.length) return null;
        
        // Hole Feld in derselben Spalte der n√§chsten/vorherigen Zeile
        const nextRow = rows[nextRowIndex];
        const nextRowFields = {
            type: nextRow.querySelector('.wire-type'),
            color: nextRow.querySelector('.wire-color'),
            cross: nextRow.querySelector('.wire-cross'),
            source: nextRow.querySelector('.wire-label-s'),
            end: nextRow.querySelector('.wire-label-e')
        };
        
        return nextRowFields[currentColumn];
    }
    
    // Pfeiltasten-Navigation im Modal
    function handleModalArrowKeys(e) {
        // Nur wenn Modal offen ist
        const modal = document.getElementById('modal');
        if (!modal || modal.style.display === 'none' || modal.style.display === '') return;
        
        // Nur Pfeiltasten abfangen
        if (!['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'].includes(e.key)) return;
        
        const activeElement = document.activeElement;
        if (!activeElement) return;
        
        // Pr√ºfe ob wir in einem Tabellenfeld sind
        const wireTable = document.getElementById('wireTable');
        if (!wireTable) return;
        
        const tbody = wireTable.querySelector('tbody');
        if (!tbody) return;
        
        // Pr√ºfe ob das aktive Element in der Tabelle ist
        const activeTr = activeElement.closest('tr');
        const isInTable = activeTr && tbody.contains(activeTr);
        
        // Wenn nicht in Tabelle, normale sequenzielle Navigation
        if (!isInTable) {
            // F√ºr Felder au√üerhalb der Tabelle: normale sequenzielle Navigation
            if (activeElement.tagName === 'INPUT' && activeElement.type === 'text') {
                const start = activeElement.selectionStart;
                const end = activeElement.selectionEnd;
                const value = activeElement.value;
                
                // Bei Links/Rechts: normale Text-Navigation erlauben, au√üer am Rand
                if (e.key === 'ArrowLeft' && start > 0) return;
                if (e.key === 'ArrowRight' && end < value.length) return;
            } else if (activeElement.tagName === 'SELECT') {
                // Bei Select-Feldern: Pfeiltasten f√ºr Dropdown-Navigation erlauben
                return;
            }
            
            // Sequenzielle Navigation f√ºr Header-Felder
            e.preventDefault();
            e.stopPropagation();
            const allFields = [];
            const fields = getAllInputFields();
            fields.header.forEach(f => { if (f) allFields.push(f); });
            fields.table.forEach(rowFields => {
                if (rowFields.type) allFields.push(rowFields.type);
                if (rowFields.color) allFields.push(rowFields.color);
                if (rowFields.cross) allFields.push(rowFields.cross);
                if (rowFields.source) allFields.push(rowFields.source);
                if (rowFields.end) allFields.push(rowFields.end);
            });
            
            const currentIndex = allFields.indexOf(activeElement);
            if (currentIndex === -1) {
                if (allFields.length > 0) allFields[0].focus();
                return;
            }
            
            let nextIndex = currentIndex;
            if (e.key === 'ArrowRight' || e.key === 'ArrowDown') {
                nextIndex = (currentIndex + 1) % allFields.length;
            } else if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') {
                nextIndex = (currentIndex - 1 + allFields.length) % allFields.length;
            }
            
            allFields[nextIndex].focus();
            if (allFields[nextIndex].tagName === 'INPUT' && allFields[nextIndex].type === 'text') {
                allFields[nextIndex].setSelectionRange(allFields[nextIndex].value.length, allFields[nextIndex].value.length);
            }
            return;
        }
        
        // Navigation innerhalb der Tabelle
        const rows = wireTable.querySelectorAll('tbody tr');
        if (rows.length === 0) return;
        
        const columnOrder = ['type', 'color', 'cross', 'source', 'end'];
        let currentRowIndex = -1;
        let currentColumnIndex = -1;
        
        // Finde aktuelle Position - suche zuerst √ºber closest('tr'), dann in allen Zeilen
        const currentTr = activeElement.closest('tr');
        if (currentTr && tbody.contains(currentTr)) {
            // Finde die Zeile
            for (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {
                if (rows[rowIndex] === currentTr) {
                    currentRowIndex = rowIndex;
                    // Finde die Spalte durch Pr√ºfung, welches Feld fokussiert ist
                    const rowFields = {
                        type: currentTr.querySelector('.wire-type'),
                        color: currentTr.querySelector('.wire-color'),
                        cross: currentTr.querySelector('.wire-cross'),
                        source: currentTr.querySelector('.wire-label-s'),
                        end: currentTr.querySelector('.wire-label-e')
                    };
                    
                    // Pr√ºfe jedes Feld in der Zeile
                    for (let colIndex = 0; colIndex < columnOrder.length; colIndex++) {
                        const field = rowFields[columnOrder[colIndex]];
                        if (field === activeElement) {
                            currentColumnIndex = colIndex;
                            break;
                        }
                    }
                    break;
                }
            }
        }
        
        // Wenn nicht gefunden, suche in allen Zeilen
        if (currentRowIndex === -1 || currentColumnIndex === -1) {
            for (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {
                const row = rows[rowIndex];
                const rowFields = {
                    type: row.querySelector('.wire-type'),
                    color: row.querySelector('.wire-color'),
                    cross: row.querySelector('.wire-cross'),
                    source: row.querySelector('.wire-label-s'),
                    end: row.querySelector('.wire-label-e')
                };
                
                for (let colIndex = 0; colIndex < columnOrder.length; colIndex++) {
                    const field = rowFields[columnOrder[colIndex]];
                    if (field === activeElement) {
                        currentRowIndex = rowIndex;
                        currentColumnIndex = colIndex;
                        break;
                    }
                }
                if (currentRowIndex !== -1 && currentColumnIndex !== -1) break;
            }
        }
        
        // Wenn immer noch nicht gefunden, beende die Funktion
        if (currentRowIndex === -1 || currentColumnIndex === -1) {
            return;
        }
        
        // Bei Hoch/Runter: in derselben Spalte zur n√§chsten/vorherigen Zeile
        // Hoch/Runter springt IMMER zur n√§chsten Zeile (keine vertikale Text-Navigation in Input-Feldern)
        if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
            e.preventDefault();
            e.stopPropagation();
            
            let nextRowIndex;
            if (e.key === 'ArrowDown') {
                nextRowIndex = currentRowIndex + 1;
            } else {
                nextRowIndex = currentRowIndex - 1;
            }
            
            if (nextRowIndex < 0 || nextRowIndex >= rows.length) return;
            
            const nextRow = rows[nextRowIndex];
            
            // Hole die Felder der n√§chsten Zeile direkt
            const nextRowFields = {
                type: nextRow.querySelector('.wire-type'),
                color: nextRow.querySelector('.wire-color'),
                cross: nextRow.querySelector('.wire-cross'),
                source: nextRow.querySelector('.wire-label-s'),
                end: nextRow.querySelector('.wire-label-e')
            };
            
            // Verwende currentColumnIndex, um das richtige Feld zu finden
            const columnKey = columnOrder[currentColumnIndex];
            const nextField = nextRowFields[columnKey];
            
            if (nextField) {
                // Fokussiere das Feld sofort
                nextField.focus();
                
                // Kurze Verz√∂gerung f√ºr zuverl√§ssige Fokussierung
                setTimeout(() => {
                    nextField.focus(); // Nochmal fokussieren
                    if (nextField.tagName === 'INPUT' && nextField.type === 'text') {
                        // Cursor ans Ende setzen
                        const len = nextField.value ? nextField.value.length : 0;
                        nextField.setSelectionRange(len, len);
                    } else if (nextField.tagName === 'SELECT') {
                        // Bei Select: fokussiere das Feld
                        nextField.focus();
                    }
                }, 10);
            }
            return;
        }
        
        // Bei Links/Rechts: zwischen Spalten wechseln
        if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
            // Pr√ºfe ob es ein Textfeld ist und der Cursor nicht am Anfang/Ende
            let shouldNavigate = true;
            if (activeElement.tagName === 'INPUT' && activeElement.type === 'text') {
                const start = activeElement.selectionStart;
                const end = activeElement.selectionEnd;
                const value = activeElement.value;
                
                // Wenn Cursor nicht am Rand, normale Text-Navigation erlauben
                if (e.key === 'ArrowLeft' && start > 0) shouldNavigate = false;
                if (e.key === 'ArrowRight' && end < value.length) shouldNavigate = false;
            } else if (activeElement.tagName === 'SELECT') {
                // Bei Select-Feldern: Pfeiltasten f√ºr Dropdown-Navigation erlauben
                // Aber nur wenn das Dropdown nicht ge√∂ffnet ist
                // Wir k√∂nnen nicht zuverl√§ssig pr√ºfen, ob das Dropdown ge√∂ffnet ist
                // Also erlauben wir die Navigation immer, au√üer wenn der Benutzer explizit im Dropdown navigiert
                // (Das wird durch die normale Select-Funktionalit√§t gehandhabt)
            }
            
            if (!shouldNavigate) return;
            
            // Verhindere Standard-Verhalten und f√ºhre Navigation durch
            e.preventDefault();
            e.stopPropagation();
            
            let nextColumnIndex = currentColumnIndex;
            let nextRowIndex = currentRowIndex;
            
            if (e.key === 'ArrowRight') {
                nextColumnIndex = currentColumnIndex + 1;
                if (nextColumnIndex >= columnOrder.length) {
                    // Ende der Zeile erreicht, gehe zur n√§chsten Zeile, erste Spalte
                    if (currentRowIndex + 1 < rows.length) {
                        nextRowIndex = currentRowIndex + 1;
                        nextColumnIndex = 0;
                    } else {
                        return; // Letzte Zeile, letzte Spalte
                    }
                }
            } else {
                nextColumnIndex = currentColumnIndex - 1;
                if (nextColumnIndex < 0) {
                    // Anfang der Zeile erreicht, gehe zur vorherigen Zeile, letzte Spalte
                    if (currentRowIndex - 1 >= 0) {
                        nextRowIndex = currentRowIndex - 1;
                        nextColumnIndex = columnOrder.length - 1;
                    } else {
                        return; // Erste Zeile, erste Spalte
                    }
                }
            }
            
            const nextRow = rows[nextRowIndex];
            const nextRowFields = {
                type: nextRow.querySelector('.wire-type'),
                color: nextRow.querySelector('.wire-color'),
                cross: nextRow.querySelector('.wire-cross'),
                source: nextRow.querySelector('.wire-label-s'),
                end: nextRow.querySelector('.wire-label-e')
            };
            
            const nextField = nextRowFields[columnOrder[nextColumnIndex]];
            if (nextField) {
                // Fokussiere das Feld sofort
                nextField.focus();
                
                // Kurze Verz√∂gerung f√ºr zuverl√§ssige Fokussierung und Cursor-Positionierung
                setTimeout(() => {
                    nextField.focus(); // Nochmal fokussieren f√ºr Sicherheit
                    if (nextField.tagName === 'INPUT' && nextField.type === 'text') {
                        const len = nextField.value ? nextField.value.length : 0;
                        nextField.setSelectionRange(len, len);
                    } else if (nextField.tagName === 'SELECT') {
                        // Bei Select: fokussiere das Feld
                        nextField.focus();
                    }
                }, 10);
            }
            return;
        }
    }
    
    // Event-Listener f√ºr Pfeiltasten hinzuf√ºgen (mit capture phase f√ºr h√∂here Priorit√§t)
    document.addEventListener('keydown', handleModalArrowKeys, true);
    
    function openModal() {
        document.getElementById('modal').style.display = 'block';
        document.getElementById('overlay').style.display = 'block';
        
        // Verstecke Gruppenauswahl f√ºr normale Kabelstr√§nge
        if (!isPatternMode) {
            document.getElementById('patternGroupSelector').style.display = 'none';
        }
        
        // Wenn Muster-Modus aktiv, √ºberschreibe die Daten NICHT (sie sind bereits in selectPattern() geladen)
        if (isPatternMode && selectedPatternIndex >= 0) {
            // Daten sind bereits geladen, nichts √ºberschreiben
            return;
        }
        
        if(editIndex === -1) {
            document.getElementById('bundleName').value = "X" + (allBundles.length + 1);
            updateWireTable();
        } else {
            const b = allBundles[editIndex];
            document.getElementById('bundleName').value = b.name;
            document.getElementById('plusStart').value = b.pS;
            document.getElementById('plusEnd').value = b.pE;
            document.getElementById('wireCount').value = b.wires.length;
            updateWireTable(b.wires);
        }
    }

    function closeModal() { 
        document.getElementById('modal').style.display = 'none'; 
        document.getElementById('overlay').style.display = 'none'; 
        if(editIndex !== -1 && mode === 'measure') {
            // Neuzeichnen-Modus bleibt aktiv
            snapshot = ctx.getImageData(0,0,canvas.width, canvas.height);
        } else {
            currentPath = []; 
            editIndex = -1;
            mode = 'none';
            document.getElementById('btnMeasure').style.background = 'var(--warning)';
            document.getElementById('btnMeasure').textContent = 'Kabelstrang zeichnen';
            document.getElementById('drawHint').style.display = 'none';
            rebuildDrawing();
        }
    }

    function updateWireTable(existingWires = null) {
        const count = parseInt(document.getElementById('wireCount').value);
        const tbody = document.querySelector("#wireTable tbody");
        tbody.innerHTML = "";
        for(let i=1; i<=count; i++) {
            const w = existingWires ? existingWires[i-1] : { t: 'H07V-K', c: 'bk', cr: '1.5', s: '', e: '' };
            tbody.innerHTML += `<tr><td>${i}</td>
                <td><input type="text" class="wire-type" value="${w.t}"></td>
                <td><select class="wire-color">
                    <option value="bk" ${w.c==='bk'?'selected':''}>Schwarz (bk)</option>
                    <option value="bl" ${w.c==='bl'?'selected':''}>Blau (bl)</option>
                    <option value="dbl" ${w.c==='dbl'?'selected':''}>Dunkelblau (dbl)</option>
                    <option value="dblws" ${w.c==='dblws'?'selected':''}>Dunkelblau-Wei√ü (dblws)</option>
                    <option value="br" ${w.c==='br'?'selected':''}>Braun (br)</option>
                    <option value="gnge" ${w.c==='gnge'?'selected':''}>Gr√ºn-Gelb (gnge)</option>
                    <option value="rt" ${w.c==='rt'?'selected':''}>Rot (rt)</option>
                    <option value="gr" ${w.c==='gr'?'selected':''}>Grau (gr)</option>
                    <option value="or" ${w.c==='or'?'selected':''}>Orange (or)</option>
                    <option value="ws" ${w.c==='ws'?'selected':''}>Wei√ü (ws)</option>
                    <option value="wsbk" ${w.c==='wsbk'?'selected':''}>Wei√ü-Schwarz (wsbk)</option>
                </select></td>
                <td><input type="text" class="wire-cross" value="${w.cr}"></td>
                <td><input type="text" class="wire-label-s" value="${w.s}" placeholder="z.B. F1"></td>
                <td><input type="text" class="wire-label-e" value="${w.e}" placeholder="z.B. X1.1"></td></tr>`;
        }
    }
    
    // Funktion zum Hinzuf√ºgen neuer Zeilen (beh√§lt alle bisherigen Eingaben)
    function addWireRows() {
        const tbody = document.querySelector("#wireTable tbody");
        const rows = tbody.querySelectorAll('tr');
        const currentCount = rows.length;
        
        // F√ºge eine neue Zeile hinzu
        const newRowNumber = currentCount + 1;
        const newRow = document.createElement('tr');
        newRow.innerHTML = `<td>${newRowNumber}</td>
            <td><input type="text" class="wire-type" value="H07V-K"></td>
            <td><select class="wire-color">
                <option value="bk" selected>Schwarz (bk)</option>
                <option value="bl">Blau (bl)</option>
                <option value="dbl">Dunkelblau (dbl)</option>
                <option value="dblws">Dunkelblau-Wei√ü (dblws)</option>
                <option value="br">Braun (br)</option>
                <option value="gnge">Gr√ºn-Gelb (gnge)</option>
                <option value="rt">Rot (rt)</option>
                <option value="gr">Grau (gr)</option>
                <option value="or">Orange (or)</option>
                <option value="ws">Wei√ü (ws)</option>
                <option value="wsbk">Wei√ü-Schwarz (wsbk)</option>
            </select></td>
            <td><input type="text" class="wire-cross" value="1.5"></td>
            <td><input type="text" class="wire-label-s" placeholder="z.B. F1"></td>
            <td><input type="text" class="wire-label-e" placeholder="z.B. X1.1"></td>`;
        
        tbody.appendChild(newRow);
        
        // Aktualisiere die Nummerierung aller Zeilen
        updateRowNumbers();
        
        // Aktualisiere wireCount
        document.getElementById('wireCount').value = tbody.querySelectorAll('tr').length;
    }
    
    // Funktion zum L√∂schen der letzten Zeile (beh√§lt alle anderen Eingaben)
    function removeLastWireRow() {
        const tbody = document.querySelector("#wireTable tbody");
        const rows = tbody.querySelectorAll('tr');
        
        if (rows.length <= 1) {
            alert("Mindestens eine Zeile muss vorhanden sein!");
            return;
        }
        
        // L√∂sche die letzte Zeile
        rows[rows.length - 1].remove();
        
        // Aktualisiere die Nummerierung aller Zeilen
        updateRowNumbers();
        
        // Aktualisiere wireCount
        document.getElementById('wireCount').value = tbody.querySelectorAll('tr').length;
    }
    
    // Hilfsfunktion zum Aktualisieren der Zeilennummern
    function updateRowNumbers() {
        const tbody = document.querySelector("#wireTable tbody");
        const rows = tbody.querySelectorAll('tr');
        rows.forEach((row, index) => {
            const numberCell = row.querySelector('td:first-child');
            if (numberCell) {
                numberCell.textContent = index + 1;
            }
        });
    }

    function saveCableBundle() {
        const bundleName = document.getElementById('bundleName').value.trim();
        if (!bundleName) {
            alert("Bitte einen Strang-Namen eingeben!");
            return;
        }
        // Pfad nur pr√ºfen, wenn nicht im Muster-Modus (Muster k√∂nnen ohne Pfad gespeichert werden)
        if (!isPatternMode && editIndex === -1 && currentPath.length < 2) {
            alert("Bitte zuerst einen Pfad zeichnen!");
            return;
        }
        const pathToUse = currentPath.length > 0 ? [...currentPath] : (editIndex === -1 ? [] : allBundles[editIndex].path);
        // Pfad-Validierung nur f√ºr normale Kabelstr√§nge (nicht f√ºr Muster)
        if (!isPatternMode && pathToUse.length < 2) {
            alert("Der Pfad muss mindestens 2 Punkte haben!");
            return;
        }
        const b = { 
            name: bundleName, 
            color: editIndex === -1 ? document.getElementById('drawColor').value : allBundles[editIndex].color,
            len: lastMeasuredLength, 
            pS: parseFloat(document.getElementById('plusStart').value) || 0, 
            pE: parseFloat(document.getElementById('plusEnd').value) || 0, 
            path: pathToUse,
            wires: [] 
        };
        // √úbernehme ALLE Adern-Daten (Typ, Farbe, Querschnitt, Bezeichnungen Quelle/Ziel)
        document.querySelectorAll("#wireTable tbody tr").forEach(r => {
            const wireType = r.querySelector(".wire-type") ? r.querySelector(".wire-type").value.trim() : '';
            const wireColor = r.querySelector(".wire-color") ? r.querySelector(".wire-color").value : 'bk';
            const wireCross = r.querySelector(".wire-cross") ? r.querySelector(".wire-cross").value.trim() : '';
            const wireLabelS = r.querySelector(".wire-label-s") ? r.querySelector(".wire-label-s").value.trim() : '';
            const wireLabelE = r.querySelector(".wire-label-e") ? r.querySelector(".wire-label-e").value.trim() : '';
            
            b.wires.push({ 
                t: wireType, 
                c: wireColor, 
                cr: wireCross, 
                s: wireLabelS, 
                e: wireLabelE 
            });
        });
        
        // Wenn Muster-Modus aktiv, speichere als Muster
        if (isPatternMode && selectedPatternIndex >= 0) {
            // Pr√ºfe ob ein Pfad gezeichnet wurde (Muster wurde ausgew√§hlt und gezeichnet)
            if (pathToUse.length >= 2) {
                // Muster wurde ausgew√§hlt und gezeichnet - speichere als Kabelstrang mit ALLEN Daten aus dem Muster
                // Alle Daten (Name, Farbe, plusStart, plusEnd, alle Adern mit Typ, Farbe, Querschnitt, Bezeichnungen) 
                // sind bereits im Bundle-Objekt 'b' enthalten
                allBundles.push(b);
                // Muster-Modus zur√ºcksetzen
                isPatternMode = false;
                selectedPatternIndex = -1;
            } else {
                // Muster wurde nur bearbeitet (ohne zu zeichnen) - speichere als Muster ohne Pfad
                const patternBundle = { ...b };
                patternBundle.path = []; // Muster haben keinen Pfad
                
                // Pr√ºfe ob es Standard-Muster sind
                if (isDefaultPatternList && selectedPatternIndex >= 0) {
                    if (!confirm('Dies ist ein Standard-Muster. M√∂chten Sie die √Ñnderungen wirklich speichern?\n\nHinweis: Die √Ñnderungen werden nur in der aktuellen Sitzung gespeichert und gehen beim Neuladen verloren.')) {
                        return;
                    }
                    // Speichere in Standard-Muster-Array
                    defaultPatternBundles[selectedPatternIndex] = patternBundle;
                } else {
                    // Setze die ausgew√§hlte Gruppe
                    const selectedGroupId = document.getElementById('patternGroupSelect') ? document.getElementById('patternGroupSelect').value : null;
                    if (selectedGroupId) {
                        patternBundle.groupId = selectedGroupId;
                    } else if (selectedPatternIndex >= 0) {
                // Behalte die alte Gruppe
                    if (isDefaultPatternList && selectedPatternIndex >= 0) {
                        patternBundle.groupId = defaultPatternBundles[selectedPatternIndex].groupId;
                    } else if (selectedPatternIndex >= 0) {
                        patternBundle.groupId = patternBundles[selectedPatternIndex].groupId;
                    }
                }
                if (isDefaultPatternList && selectedPatternIndex >= 0) {
                    defaultPatternBundles[selectedPatternIndex] = patternBundle;
                } else {
                    patternBundles[selectedPatternIndex] = patternBundle;
                }
                }
                updatePatternList();
                // Fr√ºh beenden, da Muster gespeichert wurde
                isPatternMode = false;
                selectedPatternIndex = -1;
                editIndex = -1;
                mode = 'none';
                document.getElementById('btnMeasure').style.background = 'var(--warning)';
                document.getElementById('btnMeasure').textContent = 'Kabelstrang zeichnen';
                document.getElementById('drawHint').style.display = 'none';
                updateSidebarList();
                rebuildDrawing();
                closeModal();
                return;
            }
        } else if (isPatternMode && selectedPatternIndex === -1) {
            // Neues Muster speichern (ohne Pfad, nur Vorlage)
            const patternBundle = { ...b };
            patternBundle.path = []; // Muster haben keinen Pfad
            // Setze die ausgew√§hlte Gruppe
            const selectedGroupId = document.getElementById('patternGroupSelect') ? document.getElementById('patternGroupSelect').value : null;
            if (selectedGroupId) {
                patternBundle.groupId = selectedGroupId;
            } else if (patternGroups.length > 0) {
                // Fallback: erste Gruppe verwenden
                patternBundle.groupId = patternGroups[0].id;
            }
            patternBundles.push(patternBundle);
            updatePatternList();
            isPatternMode = false;
            selectedPatternIndex = -1;
            editIndex = -1;
            mode = 'none';
            document.getElementById('btnMeasure').style.background = 'var(--warning)';
            document.getElementById('btnMeasure').textContent = 'Kabelstrang zeichnen';
            document.getElementById('drawHint').style.display = 'none';
            updateSidebarList();
            rebuildDrawing();
            closeModal();
            return; // Fr√ºh beenden, da Muster gespeichert wurde
        } else {
            // Normaler Modus: Als Kabelstrang speichern
        if(editIndex === -1) allBundles.push(b); else allBundles[editIndex] = b;
        }
        
        editIndex = -1;
        mode = 'none';
        isPatternMode = false;
        selectedPatternIndex = -1;
        document.getElementById('btnMeasure').style.background = 'var(--warning)';
        document.getElementById('btnMeasure').textContent = 'Kabelstrang zeichnen';
        document.getElementById('drawHint').style.display = 'none';
        updateSidebarList(); rebuildDrawing(); closeModal();
    }

    function updateSidebarList() {
        const container = document.getElementById('bundleContainer');
        container.innerHTML = "";
        allBundles.forEach((b, i) => {
            const wireCount = b.wires ? b.wires.length : 0;
            const length = b.len ? Math.round(b.len) : 0;
            container.innerHTML += `<div class="bundle-item">
                <div class="bundle-info">
                    <div class="color-dot" style="background: ${b.color}; cursor: pointer;" onclick="changeBundleColor(${i})" title="Farbe √§ndern"></div>
                    <div style="flex: 1;">
                        <div><strong>${b.name}</strong></div>
                        <div style="font-size: 0.75em; color: #94a3b8; margin-top: 4px;">
                            ${wireCount} Ader${wireCount !== 1 ? '(n)' : ''} | ${length}mm
                        </div>
                    </div>
                </div>
                <div class="bundle-actions" style="flex-direction: column; gap: 4px; flex-shrink: 0;">
                    <div style="display: flex; gap: 4px;">
                        <button class="action-btn" onclick="duplicateBundle(${i})" title="Duplizieren" style="background: var(--primary);">üìã</button>
                        <button class="action-btn" onclick="editBundle(${i})" title="Bearbeiten">‚úé</button>
                    </div>
                    <div style="display: flex; gap: 4px;">
                        <button class="action-btn" onclick="redrawBundle(${i})" style="background:var(--warning); color:black;" title="Neu zeichnen">‚Üª</button>
                        <button class="action-btn" onclick="deleteBundle(${i})" style="background:var(--danger)" title="L√∂schen">‚úï</button>
                    </div>
                </div>
            </div>`;
        });
    }

    function changeBundleColor(i) {
        const input = document.createElement('input');
        input.type = 'color';
        input.value = allBundles[i].color;
        input.onchange = (e) => {
            allBundles[i].color = e.target.value;
            updateSidebarList();
            rebuildDrawing();
        };
        input.click();
    }
    function editBundle(i) { editIndex = i; lastMeasuredLength = allBundles[i].len; openModal(); }
    function redrawBundle(i) {
        if(!mmPerPixel) { alert("Bitte zuerst den Ma√üstab festlegen!"); return; }
        editIndex = i;
        const b = allBundles[i];
        document.getElementById('drawColor').value = b.color;
        currentPath = [];
        mode = 'measure';
        document.getElementById('btnMeasure').style.background = 'var(--success)';
        document.getElementById('btnMeasure').textContent = 'Neu zeichnen: ' + b.name;
        document.getElementById('drawHint').style.display = 'block';
        rebuildDrawing();
        snapshot = ctx.getImageData(0,0,canvas.width, canvas.height);
    }
    function duplicateBundle(i) {
        const bundle = allBundles[i];
        
        // Erstelle eine tiefe Kopie des Kabelstrangs
        const duplicatedBundle = {
            name: bundle.name + ' (Kopie)',
            color: bundle.color,
            len: bundle.len || 0,
            pS: bundle.pS || 0,
            pE: bundle.pE || 0,
            path: bundle.path ? [...bundle.path] : [], // Pfad kopieren
            wires: bundle.wires ? bundle.wires.map(w => ({
                t: w.t || '',
                c: w.c || 'bk',
                cr: w.cr || '',
                s: w.s || '',
                e: w.e || ''
            })) : []
        };
        
        // F√ºge den duplizierten Kabelstrang hinzu
        allBundles.push(duplicatedBundle);
        updateSidebarList();
        rebuildDrawing();
        
        // √ñffne das Modal zum Bearbeiten des duplizierten Kabelstrangs
        editIndex = allBundles.length - 1;
        lastMeasuredLength = duplicatedBundle.len;
        
        // Lade Kabelstrang-Daten in das Modal
        document.getElementById('bundleName').value = duplicatedBundle.name;
        document.getElementById('drawColor').value = duplicatedBundle.color;
        document.getElementById('plusStart').value = duplicatedBundle.pS || 0;
        document.getElementById('plusEnd').value = duplicatedBundle.pE || 0;
        
        // Lade Adern
        const tbody = document.querySelector("#wireTable tbody");
        tbody.innerHTML = "";
        if (duplicatedBundle.wires && duplicatedBundle.wires.length > 0) {
            duplicatedBundle.wires.forEach((w, idx) => {
                tbody.innerHTML += `<tr>
                    <td>${idx + 1}</td>
                    <td><input type="text" class="wire-type" value="${(w.t || '').replace(/"/g, '&quot;')}"></td>
                    <td><select class="wire-color">
                        <option value="bk" ${w.c==='bk'?'selected':''}>Schwarz (bk)</option>
                        <option value="bl" ${w.c==='bl'?'selected':''}>Blau (bl)</option>
                        <option value="dbl" ${w.c==='dbl'?'selected':''}>Dunkelblau (dbl)</option>
                        <option value="dblws" ${w.c==='dblws'?'selected':''}>Dunkelblau-Wei√ü (dblws)</option>
                        <option value="br" ${w.c==='br'?'selected':''}>Braun (br)</option>
                        <option value="gnge" ${w.c==='gnge'?'selected':''}>Gr√ºn-Gelb (gnge)</option>
                        <option value="rt" ${w.c==='rt'?'selected':''}>Rot (rt)</option>
                        <option value="gr" ${w.c==='gr'?'selected':''}>Grau (gr)</option>
                        <option value="or" ${w.c==='or'?'selected':''}>Orange (or)</option>
                        <option value="ws" ${w.c==='ws'?'selected':''}>Wei√ü (ws)</option>
                        <option value="wsbk" ${w.c==='wsbk'?'selected':''}>Wei√ü-Schwarz (wsbk)</option>
                    </select></td>
                    <td><input type="text" class="wire-cross" value="${(w.cr || '').replace(/"/g, '&quot;')}"></td>
                    <td><input type="text" class="wire-label-s" value="${(w.s || '').replace(/"/g, '&quot;')}" placeholder="z.B. F1"></td>
                    <td><input type="text" class="wire-label-e" value="${(w.e || '').replace(/"/g, '&quot;')}" placeholder="z.B. X1.1"></td>
                </tr>`;
            });
        }
        
        // Setze wireCount
        document.getElementById('wireCount').value = duplicatedBundle.wires ? duplicatedBundle.wires.length : 0;
        
        // √ñffne Modal zum Bearbeiten
        openModal();
    }
    
    function deleteBundle(i) { if(confirm("L√∂schen?")) { allBundles.splice(i, 1); updateSidebarList(); rebuildDrawing(); } }

    // ========== Muster-Kabelstr√§nge Funktionen ==========
    
    function updatePatternList() {
        const container = document.getElementById('patternContainer');
        container.innerHTML = "";
        
        // Zeige zuerst Standard-Muster-Liste (wenn vorhanden)
        if (defaultPatternBundles.length > 0 || defaultPatternGroups.length > 0) {
            // Standard-Muster hei√üen immer "Standard-Muster", unabh√§ngig von importierten Mustern
            const defaultListName = 'Standard-Muster';
            container.innerHTML += `
                <div class="pattern-section" style="margin-bottom: 16px; border: 1px solid var(--card-border); border-radius: 8px; background: rgba(255,255,255,0.05);">
                    <div class="pattern-section-header" style="display: flex; align-items: center; justify-content: space-between; padding: 10px; cursor: pointer; user-select: none; background: rgba(0,120,212,0.1);" onclick="toggleDefaultPatternList()">
                        <div style="display: flex; align-items: center; gap: 8px; flex: 1;">
                            <span style="font-size: 1.2em;">${defaultPatternListCollapsed ? '‚ñ∂' : '‚ñº'}</span>
                            <strong style="flex: 1;">${defaultListName}</strong>
                            <span style="font-size: 0.85em; color: #94a3b8;">(${defaultPatternBundles.length} Muster)</span>
                        </div>
                    </div>
                    <div class="pattern-section-content" style="display: ${defaultPatternListCollapsed ? 'none' : 'block'}; padding: 10px;">
                        ${defaultPatternGroups.length === 0 ? 
                            '<div style="text-align: center; color: #94a3b8; padding: 10px; font-size: 0.9em;">Keine Gruppen vorhanden</div>' :
                            defaultPatternGroups.map((group, groupIdx) => {
                                const isCollapsed = collapsedGroups[group.id] !== undefined ? collapsedGroups[group.id] : true;
                                const groupPatterns = defaultPatternBundles.filter(p => p.groupId === group.id);
                                
                                return `
                                    <div class="pattern-group" style="margin-bottom: 10px; border: 1px solid var(--card-border); border-radius: 8px; background: rgba(255,255,255,0.05);">
                                        <div class="pattern-group-header" style="display: flex; align-items: center; justify-content: space-between; padding: 10px; cursor: pointer; user-select: none;" onclick="togglePatternGroup('${group.id}')">
                                            <div style="display: flex; align-items: center; gap: 8px; flex: 1;">
                                                <span style="font-size: 1.2em;">${isCollapsed ? '‚ñ∂' : '‚ñº'}</span>
                                                <strong style="flex: 1;">${group.name}</strong>
                                                <span style="font-size: 0.85em; color: #94a3b8;">(${groupPatterns.length} Muster)</span>
                                            </div>
                                        </div>
                                        <div class="pattern-group-content" style="display: ${isCollapsed ? 'none' : 'block'}; padding: 0 10px 10px 10px;">
                                            ${groupPatterns.length === 0 ? 
                                                '<div style="text-align: center; color: #94a3b8; padding: 10px; font-size: 0.9em;">Keine Muster in dieser Gruppe</div>' :
                                                groupPatterns.map((p, idx) => {
                                                    const globalIndex = defaultPatternBundles.findIndex(b => b === p);
                                                    return `<div class="bundle-item" style="margin-top: 8px; ${selectedPatternIndex === globalIndex ? 'border: 2px solid var(--primary);' : ''}">
                                                        <div class="bundle-info" style="flex: 1; min-width: 0; overflow: hidden;">
                                                            <div class="color-dot" style="background: ${p.color}; flex-shrink: 0;"></div>
                                                            <div style="flex: 1; min-width: 0; overflow: hidden;">
                                                                <div style="word-wrap: break-word; overflow-wrap: break-word;"><strong>${p.name}</strong></div>
                                                                <div style="font-size: 0.75em; color: #94a3b8; margin-top: 4px;">
                                                                    ${p.wires ? p.wires.length : 0} Ader(n) | ${p.len ? p.len.toFixed(0) : '?'}mm
                                                                </div>
                                                            </div>
                                                        </div>
                                                        <div class="bundle-actions" style="flex-direction: column; gap: 4px; flex-shrink: 0;">
                                                            <div style="display: flex; gap: 4px;">
                                                                <button class="action-btn" onclick="selectDefaultPattern(${globalIndex})" title="Muster ausw√§hlen" style="background: var(--success);">‚úì</button>
                                                                <button class="action-btn" onclick="duplicateDefaultPattern(${globalIndex})" title="Duplizieren" style="background: var(--primary);">üìã</button>
                                                            </div>
                                                            <div style="display: flex; gap: 4px;">
                                                                <button class="action-btn" onclick="editDefaultPattern(${globalIndex})" title="Bearbeiten">‚úé</button>
                                                                <button class="action-btn" onclick="deleteDefaultPattern(${globalIndex})" style="background: var(--danger)" title="L√∂schen">‚úï</button>
                                                            </div>
                                                        </div>
                                                    </div>`;
                                                }).join('')
                                            }
                                        </div>
                                    </div>
                                `;
                            }).join('')
                        }
                    </div>
                </div>
            `;
        }
        
        // Zeige dann neue/importierte Muster-Liste
        if (patternBundles.length > 0 || patternGroups.length > 0) {
            // Wenn keine Gruppen vorhanden, erstelle eine Standard-Gruppe
            if (patternGroups.length === 0 && patternBundles.length > 0) {
                const defaultGroupId = 'group_' + Date.now();
                // Verwende den Namen des importierten Musters, falls vorhanden, sonst "Neues Muster"
                const groupName = patternListName || 'Neues Muster';
                patternGroups.push({ id: defaultGroupId, name: groupName, collapsed: false });
                // Ordne alle vorhandenen Muster der Standard-Gruppe zu
                patternBundles.forEach(p => {
                    if (!p.groupId) p.groupId = defaultGroupId;
                });
            }
            
            const customListName = 'importierte Muster';
            container.innerHTML += `
                <div class="pattern-section" style="margin-top: 16px; border: 1px solid var(--card-border); border-radius: 8px; background: rgba(255,255,255,0.05);">
                    <div class="pattern-section-header" style="display: flex; align-items: center; justify-content: space-between; padding: 10px; cursor: pointer; user-select: none; background: rgba(16,124,16,0.1);">
                        <div style="display: flex; align-items: center; gap: 8px; flex: 1;">
                            <strong style="flex: 1;">${customListName}</strong>
                            <span style="font-size: 0.85em; color: #94a3b8;">(${patternBundles.length} Muster)</span>
                        </div>
                    </div>
                    <div class="pattern-section-content" style="display: block; padding: 10px;">
                        ${patternGroups.map((group, groupIdx) => {
                            const isCollapsed = collapsedGroups[group.id] !== undefined ? collapsedGroups[group.id] : true;
                            const groupPatterns = patternBundles.filter(p => p.groupId === group.id);
                            
                            return `
                                <div class="pattern-group" style="margin-bottom: 10px; border: 1px solid var(--card-border); border-radius: 8px; background: rgba(255,255,255,0.05);">
                                    <div class="pattern-group-header" style="display: flex; align-items: center; justify-content: space-between; padding: 10px; cursor: pointer; user-select: none;" onclick="togglePatternGroup('${group.id}')">
                                        <div style="display: flex; align-items: center; gap: 8px; flex: 1;">
                                            <span style="font-size: 1.2em;">${isCollapsed ? '‚ñ∂' : '‚ñº'}</span>
                                            <strong style="flex: 1;">${group.name}</strong>
                                            <span style="font-size: 0.85em; color: #94a3b8;">(${groupPatterns.length} Muster)</span>
                                        </div>
                                        <div style="display: flex; gap: 4px;">
                                            <button class="action-btn" onclick="event.stopPropagation(); renamePatternGroup('${group.id}')" title="Gruppe umbenennen" style="background: var(--primary); font-size: 12px; padding: 4px 8px;">‚úé</button>
                                            <button class="action-btn" onclick="event.stopPropagation(); deletePatternGroup('${group.id}')" title="Gruppe l√∂schen" style="background: var(--danger); font-size: 12px; padding: 4px 8px;">‚úï</button>
                                        </div>
                                    </div>
                                    <div class="pattern-group-content" style="display: ${isCollapsed ? 'none' : 'block'}; padding: 0 10px 10px 10px;">
                                        ${groupPatterns.length === 0 ? 
                                            '<div style="text-align: center; color: #94a3b8; padding: 10px; font-size: 0.9em;">Keine Muster in dieser Gruppe</div>' :
                                            groupPatterns.map((p, idx) => {
                                                const globalIndex = patternBundles.findIndex(b => b === p);
                                                return `<div class="bundle-item" style="margin-top: 8px; ${selectedPatternIndex === globalIndex ? 'border: 2px solid var(--primary);' : ''}">
                                                    <div class="bundle-info" style="flex: 1; min-width: 0; overflow: hidden;">
                                                        <div class="color-dot" style="background: ${p.color}; flex-shrink: 0;"></div>
                                                        <div style="flex: 1; min-width: 0; overflow: hidden;">
                                                            <div style="word-wrap: break-word; overflow-wrap: break-word;"><strong>${p.name}</strong></div>
                                                            <div style="font-size: 0.75em; color: #94a3b8; margin-top: 4px;">
                                                                ${p.wires ? p.wires.length : 0} Ader(n) | ${p.len ? p.len.toFixed(0) : '?'}mm
                                                            </div>
                                                        </div>
                                                    </div>
                                                    <div class="bundle-actions" style="flex-direction: column; gap: 4px; flex-shrink: 0;">
                                                        <div style="display: flex; gap: 4px;">
                                                            <button class="action-btn" onclick="selectPattern(${globalIndex})" title="Muster ausw√§hlen" style="background: var(--success);">‚úì</button>
                                                            <button class="action-btn" onclick="duplicatePattern(${globalIndex})" title="Duplizieren" style="background: var(--primary);">üìã</button>
                                                        </div>
                                                        <div style="display: flex; gap: 4px;">
                                                            <button class="action-btn" onclick="editPattern(${globalIndex})" title="Bearbeiten">‚úé</button>
                                                            <button class="action-btn" onclick="deletePattern(${globalIndex})" style="background: var(--danger)" title="L√∂schen">‚úï</button>
                                                        </div>
                                                    </div>
                                                </div>`;
                                            }).join('')
                                        }
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                </div>
            `;
        }
        
        // Wenn keine Muster vorhanden
        if ((defaultPatternBundles.length === 0 && defaultPatternGroups.length === 0) && 
            (patternBundles.length === 0 && patternGroups.length === 0)) {
            container.innerHTML = '<div style="text-align: center; color: #94a3b8; padding: 20px;">Keine Muster vorhanden</div>';
        }
    }
    
    function togglePatternGroup(groupId) {
        collapsedGroups[groupId] = !collapsedGroups[groupId];
        updatePatternList();
    }
    
    function togglePatternManagement() {
        patternManagementCollapsed = !patternManagementCollapsed;
        const content = document.getElementById('patternManagementContent');
        const toggle = document.getElementById('patternManagementToggle');
        
        if (patternManagementCollapsed) {
            content.style.display = 'none';
            toggle.textContent = '‚ñ∂';
        } else {
            content.style.display = 'block';
            toggle.textContent = '‚ñº';
        }
    }
    
    function toggleDefaultPatternList() {
        defaultPatternListCollapsed = !defaultPatternListCollapsed;
        updatePatternList();
    }
    
    // Funktionen f√ºr Standard-Muster
    function selectDefaultPattern(i) {
        if (!mmPerPixel) {
            alert("Bitte zuerst den Ma√üstab festlegen!");
            return;
        }
        selectedPatternIndex = i;
        isPatternMode = true;
        isDefaultPatternList = true;
        const pattern = defaultPatternBundles[i];
        
        // Lade Muster-Daten in das Modal
        document.getElementById('bundleName').value = pattern.name;
        document.getElementById('drawColor').value = pattern.color;
        document.getElementById('plusStart').value = pattern.pS || 0;
        document.getElementById('plusEnd').value = pattern.pE || 0;
        
        // Lade Adern
        const tbody = document.querySelector("#wireTable tbody");
        tbody.innerHTML = "";
        pattern.wires.forEach((w, idx) => {
            tbody.innerHTML += `<tr>
                <td>${idx + 1}</td>
                <td><input type="text" class="wire-type" value="${(w.t || '').replace(/"/g, '&quot;')}"></td>
                <td><select class="wire-color">
                    <option value="bk" ${w.c==='bk'?'selected':''}>Schwarz (bk)</option>
                    <option value="bl" ${w.c==='bl'?'selected':''}>Blau (bl)</option>
                    <option value="dbl" ${w.c==='dbl'?'selected':''}>Dunkelblau (dbl)</option>
                    <option value="dblws" ${w.c==='dblws'?'selected':''}>Dunkelblau-Wei√ü (dblws)</option>
                    <option value="br" ${w.c==='br'?'selected':''}>Braun (br)</option>
                    <option value="gnge" ${w.c==='gnge'?'selected':''}>Gr√ºn-Gelb (gnge)</option>
                    <option value="rt" ${w.c==='rt'?'selected':''}>Rot (rt)</option>
                    <option value="gr" ${w.c==='gr'?'selected':''}>Grau (gr)</option>
                    <option value="or" ${w.c==='or'?'selected':''}>Orange (or)</option>
                    <option value="ws" ${w.c==='ws'?'selected':''}>Wei√ü (ws)</option>
                    <option value="wsbk" ${w.c==='wsbk'?'selected':''}>Wei√ü-Schwarz (wsbk)</option>
                </select></td>
                <td><input type="text" class="wire-cross" value="${(w.cr || '').replace(/"/g, '&quot;')}"></td>
                <td><input type="text" class="wire-label-s" value="${(w.s || '').replace(/"/g, '&quot;')}" placeholder="z.B. F1"></td>
                <td><input type="text" class="wire-label-e" value="${(w.e || '').replace(/"/g, '&quot;')}" placeholder="z.B. X1.1"></td>
            </tr>`;
        });
        
        // Setze wireCount
        document.getElementById('wireCount').value = pattern.wires ? pattern.wires.length : 0;
        
        // Verstecke Gruppenauswahl f√ºr Standard-Muster
        document.getElementById('patternGroupSelector').style.display = 'none';
        
        // NICHT Modal √∂ffnen - nur Daten laden und Zeichnen-Modus starten
        // Das Modal wird erst beim Speichern ge√∂ffnet, damit der Benutzer zeichnen kann
        
        // Starte Zeichnen-Modus
        currentPath = [];
        mode = 'measure';
        editIndex = -1; // Wichtig: Nicht als normalen Kabelstrang bearbeiten
        document.getElementById('btnMeasure').style.background = 'var(--success)';
        document.getElementById('btnMeasure').textContent = 'Muster zeichnen: ' + pattern.name;
        document.getElementById('drawHint').style.display = 'block';
        updatePatternList();
        rebuildDrawing();
    }
    
    function duplicateDefaultPattern(i) {
        const pattern = defaultPatternBundles[i];
        
        // Erstelle eine tiefe Kopie des Musters
        const duplicatedPattern = {
            name: pattern.name + ' (Kopie)',
            color: pattern.color,
            len: pattern.len || 0,
            pS: pattern.pS || 0,
            pE: pattern.pE || 0,
            path: [],
            wires: pattern.wires ? pattern.wires.map(w => ({
                t: w.t || '',
                c: w.c || 'bk',
                cr: w.cr || '',
                s: w.s || '',
                e: w.e || ''
            })) : []
        };
        
        // F√ºge das duplizierte Muster zu den neuen Mustern hinzu
        patternBundles.push(duplicatedPattern);
        updatePatternList();
        
        // √ñffne das Modal zum Bearbeiten des duplizierten Musters
        selectedPatternIndex = patternBundles.length - 1;
        isPatternMode = true;
        isDefaultPatternList = false;
        editIndex = -1;
        
        // Lade Muster-Daten in das Modal
        document.getElementById('bundleName').value = duplicatedPattern.name;
        document.getElementById('drawColor').value = duplicatedPattern.color;
        document.getElementById('plusStart').value = duplicatedPattern.pS || 0;
        document.getElementById('plusEnd').value = duplicatedPattern.pE || 0;
        
        // Lade Adern
        const tbody = document.querySelector("#wireTable tbody");
        tbody.innerHTML = "";
        if (duplicatedPattern.wires && duplicatedPattern.wires.length > 0) {
            duplicatedPattern.wires.forEach((w, idx) => {
                tbody.innerHTML += `<tr>
                    <td>${idx + 1}</td>
                    <td><input type="text" class="wire-type" value="${(w.t || '').replace(/"/g, '&quot;')}"></td>
                    <td><select class="wire-color">
                        <option value="bk" ${w.c==='bk'?'selected':''}>Schwarz (bk)</option>
                        <option value="bl" ${w.c==='bl'?'selected':''}>Blau (bl)</option>
                        <option value="dbl" ${w.c==='dbl'?'selected':''}>Dunkelblau (dbl)</option>
                        <option value="dblws" ${w.c==='dblws'?'selected':''}>Dunkelblau-Wei√ü (dblws)</option>
                        <option value="br" ${w.c==='br'?'selected':''}>Braun (br)</option>
                        <option value="gnge" ${w.c==='gnge'?'selected':''}>Gr√ºn-Gelb (gnge)</option>
                        <option value="rt" ${w.c==='rt'?'selected':''}>Rot (rt)</option>
                        <option value="gr" ${w.c==='gr'?'selected':''}>Grau (gr)</option>
                        <option value="or" ${w.c==='or'?'selected':''}>Orange (or)</option>
                        <option value="ws" ${w.c==='ws'?'selected':''}>Wei√ü (ws)</option>
                        <option value="wsbk" ${w.c==='wsbk'?'selected':''}>Wei√ü-Schwarz (wsbk)</option>
                    </select></td>
                    <td><input type="text" class="wire-cross" value="${(w.cr || '').replace(/"/g, '&quot;')}"></td>
                    <td><input type="text" class="wire-label-s" value="${(w.s || '').replace(/"/g, '&quot;')}" placeholder="z.B. F1"></td>
                    <td><input type="text" class="wire-label-e" value="${(w.e || '').replace(/"/g, '&quot;')}" placeholder="z.B. X1.1"></td>
                </tr>`;
            });
        }
        
        // Setze wireCount
        document.getElementById('wireCount').value = duplicatedPattern.wires ? duplicatedPattern.wires.length : 0;
        
        // Zeige Gruppenauswahl
        updatePatternGroupSelector();
        document.getElementById('patternGroupSelector').style.display = 'block';
        if (patternGroups.length > 0) {
            document.getElementById('patternGroupSelect').value = patternGroups[0].id;
        }
        
        // √ñffne Modal zum Bearbeiten
        openModal();
        
        // Fokussiere das Name-Feld
        setTimeout(() => {
            const nameField = document.getElementById('bundleName');
            if (nameField) {
                nameField.focus();
                nameField.select();
            }
        }, 100);
    }
    
    function editDefaultPattern(i) {
        // Pr√ºfe ob es Standard-Muster sind
        if (!confirm('Dies ist ein Standard-Muster. M√∂chten Sie es wirklich bearbeiten?\n\nHinweis: Die √Ñnderungen werden nur in der aktuellen Sitzung gespeichert und gehen beim Neuladen verloren.')) {
            return;
        }
        
        selectedPatternIndex = i;
        isPatternMode = true;
        isDefaultPatternList = true;
        const pattern = defaultPatternBundles[i];
        
        // Lade Muster-Daten in das Modal
        document.getElementById('bundleName').value = pattern.name;
        document.getElementById('drawColor').value = pattern.color;
        document.getElementById('plusStart').value = pattern.pS || 0;
        document.getElementById('plusEnd').value = pattern.pE || 0;
        
        // Lade Adern
        const tbody = document.querySelector("#wireTable tbody");
        tbody.innerHTML = "";
        pattern.wires.forEach((w, idx) => {
            tbody.innerHTML += `<tr>
                <td>${idx + 1}</td>
                <td><input type="text" class="wire-type" value="${(w.t || '').replace(/"/g, '&quot;')}"></td>
                <td><select class="wire-color">
                    <option value="bk" ${w.c==='bk'?'selected':''}>Schwarz (bk)</option>
                    <option value="bl" ${w.c==='bl'?'selected':''}>Blau (bl)</option>
                    <option value="dbl" ${w.c==='dbl'?'selected':''}>Dunkelblau (dbl)</option>
                    <option value="dblws" ${w.c==='dblws'?'selected':''}>Dunkelblau-Wei√ü (dblws)</option>
                    <option value="br" ${w.c==='br'?'selected':''}>Braun (br)</option>
                    <option value="gnge" ${w.c==='gnge'?'selected':''}>Gr√ºn-Gelb (gnge)</option>
                    <option value="rt" ${w.c==='rt'?'selected':''}>Rot (rt)</option>
                    <option value="gr" ${w.c==='gr'?'selected':''}>Grau (gr)</option>
                    <option value="or" ${w.c==='or'?'selected':''}>Orange (or)</option>
                    <option value="ws" ${w.c==='ws'?'selected':''}>Wei√ü (ws)</option>
                    <option value="wsbk" ${w.c==='wsbk'?'selected':''}>Wei√ü-Schwarz (wsbk)</option>
                </select></td>
                <td><input type="text" class="wire-cross" value="${(w.cr || '').replace(/"/g, '&quot;')}"></td>
                <td><input type="text" class="wire-label-s" value="${(w.s || '').replace(/"/g, '&quot;')}" placeholder="z.B. F1"></td>
                <td><input type="text" class="wire-label-e" value="${(w.e || '').replace(/"/g, '&quot;')}" placeholder="z.B. X1.1"></td>
                <td><button class="action-btn" onclick="this.parentElement.parentElement.remove()" style="background: var(--danger); width: 24px; height: 24px; font-size: 12px;">‚úï</button></td>
            </tr>`;
        });
        
        // Verstecke Gruppenauswahl f√ºr Standard-Muster
        document.getElementById('patternGroupSelector').style.display = 'none';
        
        openModal();
    }
    
    function deleteDefaultPattern(i) {
        if (!confirm('Dies ist ein Standard-Muster. M√∂chten Sie es wirklich l√∂schen?\n\nHinweis: Das Muster wird nur in der aktuellen Sitzung gel√∂scht und wird beim Neuladen wieder erscheinen.')) {
            return;
        }
        
        defaultPatternBundles.splice(i, 1);
        updatePatternList();
    }
    
    function createPatternGroup() {
        const groupName = prompt("Bitte geben Sie den Namen der neuen Gruppe ein:");
        if (!groupName || !groupName.trim()) {
            return;
        }
        const groupId = 'group_' + Date.now();
        patternGroups.push({ id: groupId, name: groupName.trim(), collapsed: false });
        updatePatternList();
    }
    
    function renamePatternGroup(groupId) {
        const group = patternGroups.find(g => g.id === groupId);
        if (!group) return;
        const newName = prompt("Bitte geben Sie den neuen Namen ein:", group.name);
        if (newName && newName.trim()) {
            group.name = newName.trim();
            updatePatternList();
        }
    }
    
    function deletePatternGroup(groupId) {
        const group = patternGroups.find(g => g.id === groupId);
        if (!group) return;
        const groupPatterns = patternBundles.filter(p => p.groupId === groupId);
        
        if (groupPatterns.length > 0) {
            if (!confirm(`Die Gruppe "${group.name}" enth√§lt ${groupPatterns.length} Muster. M√∂chten Sie die Gruppe wirklich l√∂schen? Die Muster werden ebenfalls gel√∂scht.`)) {
                return;
            }
            // L√∂sche alle Muster dieser Gruppe
            groupPatterns.forEach(p => {
                const index = patternBundles.indexOf(p);
                if (index > -1) patternBundles.splice(index, 1);
            });
        }
        
        // L√∂sche die Gruppe
        const groupIndex = patternGroups.indexOf(group);
        if (groupIndex > -1) patternGroups.splice(groupIndex, 1);
        
        // Wenn keine Gruppen mehr vorhanden, erstelle Standard-Gruppe
        if (patternGroups.length === 0) {
            const defaultGroupId = 'group_' + Date.now();
            patternGroups.push({ id: defaultGroupId, name: 'Neues Muster', collapsed: false });
        }
        
        updatePatternList();
    }
    
    function deletePatternGroupFromList() {
        if (patternGroups.length === 0) {
            alert("Keine Gruppen vorhanden!");
            return;
        }
        
        // Erstelle Auswahl-Liste
        let groupList = "Bitte w√§hlen Sie die zu l√∂schende Gruppe:\n\n";
        patternGroups.forEach((group, index) => {
            const groupPatterns = patternBundles.filter(p => p.groupId === group.id);
            groupList += `${index + 1}. ${group.name} (${groupPatterns.length} Muster)\n`;
        });
        
        const selection = prompt(groupList + "\nGeben Sie die Nummer ein:");
        if (!selection) return;
        
        const selectedIndex = parseInt(selection) - 1;
        if (isNaN(selectedIndex) || selectedIndex < 0 || selectedIndex >= patternGroups.length) {
            alert("Ung√ºltige Auswahl!");
            return;
        }
        
        const selectedGroup = patternGroups[selectedIndex];
        deletePatternGroup(selectedGroup.id);
    }
    
    function selectPattern(i) {
        if (!mmPerPixel) {
            alert("Bitte zuerst den Ma√üstab festlegen!");
            return;
        }
        selectedPatternIndex = i;
        isPatternMode = true;
        const pattern = patternBundles[i];
        
        // Lade ALLE Muster-Daten in das Modal (Name, Farbe, plusStart, plusEnd, alle Adern)
        document.getElementById('bundleName').value = pattern.name || '';
        document.getElementById('drawColor').value = pattern.color || '#f39c12';
        document.getElementById('plusStart').value = pattern.pS || 0;
        document.getElementById('plusEnd').value = pattern.pE || 0;
        
        // Lade ALLE Adern-Daten (Typ, Farbe, Querschnitt, Bezeichnungen)
        // WICHTIG: Setze wireCount, damit updateWireTable() nicht die Daten √ºberschreibt
        document.getElementById('wireCount').value = pattern.wires ? pattern.wires.length : 0;
        
        const tbody = document.querySelector("#wireTable tbody");
        tbody.innerHTML = "";
        if (pattern.wires && pattern.wires.length > 0) {
            pattern.wires.forEach((w, idx) => {
                tbody.innerHTML += `<tr>
                    <td>${idx + 1}</td>
                    <td><input type="text" class="wire-type" value="${(w.t || '').replace(/"/g, '&quot;')}"></td>
                    <td><select class="wire-color">
                        <option value="bk" ${w.c==='bk'?'selected':''}>Schwarz (bk)</option>
                        <option value="bl" ${w.c==='bl'?'selected':''}>Blau (bl)</option>
                        <option value="dbl" ${w.c==='dbl'?'selected':''}>Dunkelblau (dbl)</option>
                        <option value="dblws" ${w.c==='dblws'?'selected':''}>Dunkelblau-Wei√ü (dblws)</option>
                        <option value="br" ${w.c==='br'?'selected':''}>Braun (br)</option>
                        <option value="gnge" ${w.c==='gnge'?'selected':''}>Gr√ºn-Gelb (gnge)</option>
                        <option value="rt" ${w.c==='rt'?'selected':''}>Rot (rt)</option>
                        <option value="gr" ${w.c==='gr'?'selected':''}>Grau (gr)</option>
                        <option value="or" ${w.c==='or'?'selected':''}>Orange (or)</option>
                        <option value="ws" ${w.c==='ws'?'selected':''}>Wei√ü (ws)</option>
                        <option value="wsbk" ${w.c==='wsbk'?'selected':''}>Wei√ü-Schwarz (wsbk)</option>
                    </select></td>
                    <td><input type="text" class="wire-cross" value="${(w.cr || '').replace(/"/g, '&quot;')}"></td>
                    <td><input type="text" class="wire-label-s" value="${(w.s || '').replace(/"/g, '&quot;')}" placeholder="z.B. F1"></td>
                    <td><input type="text" class="wire-label-e" value="${(w.e || '').replace(/"/g, '&quot;')}" placeholder="z.B. X1.1"></td>
                </tr>`;
            });
        }
        
        // NICHT Modal √∂ffnen - nur Daten laden und Zeichnen-Modus starten
        // Das Modal wird erst beim Speichern ge√∂ffnet, damit der Benutzer zeichnen kann
        
        // Starte Zeichnen-Modus
        currentPath = [];
        mode = 'measure';
        editIndex = -1; // Wichtig: Nicht als normalen Kabelstrang bearbeiten
        document.getElementById('btnMeasure').style.background = 'var(--success)';
        document.getElementById('btnMeasure').textContent = 'Muster zeichnen: ' + pattern.name;
        document.getElementById('drawHint').style.display = 'block';
        updatePatternList();
        rebuildDrawing();
    }
    
    function openPatternModal() {
        // √ñffne Modal f√ºr neues Muster
        selectedPatternIndex = -1;
        isPatternMode = true;
        document.getElementById('bundleName').value = '';
        document.getElementById('drawColor').value = '#f39c12';
        document.getElementById('plusStart').value = 0;
        document.getElementById('plusEnd').value = 0;
        document.querySelector("#wireTable tbody").innerHTML = "";
        
        // Zeige Gruppenauswahl und f√ºlle sie
        updatePatternGroupSelector();
        document.getElementById('patternGroupSelector').style.display = 'block';
        
        openModal();
    }
    
    function updatePatternGroupSelector() {
        const select = document.getElementById('patternGroupSelect');
        select.innerHTML = '';
        
        // Wenn keine Gruppen vorhanden, erstelle eine Standard-Gruppe
        if (patternGroups.length === 0) {
            const defaultGroupId = 'group_' + Date.now();
            patternGroups.push({ id: defaultGroupId, name: 'Neues Muster', collapsed: false });
        }
        
        patternGroups.forEach(group => {
            const option = document.createElement('option');
            option.value = group.id;
            option.textContent = group.name;
            select.appendChild(option);
        });
    }
    
    function editPattern(i) {
        // Pr√ºfe ob es Standard-Muster sind
        if (isDefaultPatternList) {
            if (!confirm('Dies ist ein Standard-Muster. M√∂chten Sie es wirklich bearbeiten?\n\nHinweis: Die √Ñnderungen werden nur in der aktuellen Sitzung gespeichert und gehen beim Neuladen verloren.')) {
                return;
            }
        }
        
        selectedPatternIndex = i;
        isPatternMode = true;
        const pattern = patternBundles[i];
        
        // Lade Muster-Daten in das Modal
        document.getElementById('bundleName').value = pattern.name;
        document.getElementById('drawColor').value = pattern.color;
        document.getElementById('plusStart').value = pattern.pS || 0;
        document.getElementById('plusEnd').value = pattern.pE || 0;
        
        // Lade Adern
        const tbody = document.querySelector("#wireTable tbody");
        tbody.innerHTML = "";
        pattern.wires.forEach((w, idx) => {
            // Gleiche Spaltenstruktur wie in updateWireTable / selectPattern / duplicatePattern:
            //  # | Typ | Farbe | mm¬≤ | Quelle | Ziel | (optional L√∂schen)
            tbody.innerHTML += `<tr>
                <td>${idx + 1}</td>
                <td><input type="text" class="wire-type" value="${(w.t || '').replace(/"/g, '&quot;')}"></td>
                <td><select class="wire-color">
                    <option value="bk" ${w.c==='bk'?'selected':''}>Schwarz (bk)</option>
                    <option value="bl" ${w.c==='bl'?'selected':''}>Blau (bl)</option>
                    <option value="dbl" ${w.c==='dbl'?'selected':''}>Dunkelblau (dbl)</option>
                    <option value="dblws" ${w.c==='dblws'?'selected':''}>Dunkelblau-Wei√ü (dblws)</option>
                    <option value="br" ${w.c==='br'?'selected':''}>Braun (br)</option>
                    <option value="gnge" ${w.c==='gnge'?'selected':''}>Gr√ºn-Gelb (gnge)</option>
                    <option value="rt" ${w.c==='rt'?'selected':''}>Rot (rt)</option>
                    <option value="gr" ${w.c==='gr'?'selected':''}>Grau (gr)</option>
                    <option value="or" ${w.c==='or'?'selected':''}>Orange (or)</option>
                    <option value="ws" ${w.c==='ws'?'selected':''}>Wei√ü (ws)</option>
                    <option value="wsbk" ${w.c==='wsbk'?'selected':''}>Wei√ü-Schwarz (wsbk)</option>
                </select></td>
                <td><input type="text" class="wire-cross" value="${(w.cr || '').replace(/"/g, '&quot;')}"></td>
                <td><input type="text" class="wire-label-s" value="${(w.s || '').replace(/"/g, '&quot;')}" placeholder="z.B. F1"></td>
                <td><input type="text" class="wire-label-e" value="${(w.e || '').replace(/"/g, '&quot;')}" placeholder="z.B. X1.1"></td>
                <td><button class="action-btn" onclick="this.parentElement.parentElement.remove()" style="background: var(--danger); width: 24px; height: 24px; font-size: 12px;">‚úï</button></td>
            </tr>`;
        });
        
        // Zeige Gruppenauswahl und setze die aktuelle Gruppe
        updatePatternGroupSelector();
        document.getElementById('patternGroupSelector').style.display = 'block';
        if (pattern.groupId) {
            document.getElementById('patternGroupSelect').value = pattern.groupId;
        } else if (patternGroups.length > 0) {
            document.getElementById('patternGroupSelect').value = patternGroups[0].id;
        }
        
        openModal();
    }
    
    function duplicatePattern(i) {
        const pattern = patternBundles[i];
        
        // Erstelle eine tiefe Kopie des Musters
        const duplicatedPattern = {
            name: pattern.name + ' (Kopie)',
            color: pattern.color,
            len: pattern.len || 0,
            pS: pattern.pS || 0,
            pE: pattern.pE || 0,
            path: [],
            wires: pattern.wires ? pattern.wires.map(w => ({
                t: w.t || '',
                c: w.c || 'bk',
                cr: w.cr || '',
                s: w.s || '',
                e: w.e || ''
            })) : []
        };
        
        // F√ºge das duplizierte Muster hinzu
        patternBundles.push(duplicatedPattern);
        updatePatternList();
        
        // √ñffne das Modal zum Bearbeiten des duplizierten Musters
        selectedPatternIndex = patternBundles.length - 1;
        isPatternMode = true;
        editIndex = -1; // Wichtig: Nicht als normalen Kabelstrang bearbeiten
        
        // Lade Muster-Daten in das Modal
        document.getElementById('bundleName').value = duplicatedPattern.name;
        document.getElementById('drawColor').value = duplicatedPattern.color;
        document.getElementById('plusStart').value = duplicatedPattern.pS || 0;
        document.getElementById('plusEnd').value = duplicatedPattern.pE || 0;
        
        // Lade Adern
        const tbody = document.querySelector("#wireTable tbody");
        tbody.innerHTML = "";
        if (duplicatedPattern.wires && duplicatedPattern.wires.length > 0) {
            duplicatedPattern.wires.forEach((w, idx) => {
                tbody.innerHTML += `<tr>
                    <td>${idx + 1}</td>
                    <td><input type="text" class="wire-type" value="${(w.t || '').replace(/"/g, '&quot;')}"></td>
                    <td><select class="wire-color">
                        <option value="bk" ${w.c==='bk'?'selected':''}>Schwarz (bk)</option>
                        <option value="bl" ${w.c==='bl'?'selected':''}>Blau (bl)</option>
                        <option value="dbl" ${w.c==='dbl'?'selected':''}>Dunkelblau (dbl)</option>
                        <option value="dblws" ${w.c==='dblws'?'selected':''}>Dunkelblau-Wei√ü (dblws)</option>
                        <option value="br" ${w.c==='br'?'selected':''}>Braun (br)</option>
                        <option value="gnge" ${w.c==='gnge'?'selected':''}>Gr√ºn-Gelb (gnge)</option>
                        <option value="rt" ${w.c==='rt'?'selected':''}>Rot (rt)</option>
                        <option value="gr" ${w.c==='gr'?'selected':''}>Grau (gr)</option>
                        <option value="or" ${w.c==='or'?'selected':''}>Orange (or)</option>
                        <option value="ws" ${w.c==='ws'?'selected':''}>Wei√ü (ws)</option>
                        <option value="wsbk" ${w.c==='wsbk'?'selected':''}>Wei√ü-Schwarz (wsbk)</option>
                    </select></td>
                    <td><input type="text" class="wire-cross" value="${(w.cr || '').replace(/"/g, '&quot;')}"></td>
                    <td><input type="text" class="wire-label-s" value="${(w.s || '').replace(/"/g, '&quot;')}" placeholder="z.B. F1"></td>
                    <td><input type="text" class="wire-label-e" value="${(w.e || '').replace(/"/g, '&quot;')}" placeholder="z.B. X1.1"></td>
                </tr>`;
            });
        }
        
        // Setze wireCount
        document.getElementById('wireCount').value = duplicatedPattern.wires ? duplicatedPattern.wires.length : 0;
        
        // Zeige Gruppenauswahl und setze die Gruppe des Original-Musters
        updatePatternGroupSelector();
        document.getElementById('patternGroupSelector').style.display = 'block';
        if (pattern.groupId) {
            document.getElementById('patternGroupSelect').value = pattern.groupId;
        }
        
        // √ñffne Modal zum Bearbeiten
        openModal();
        
        // Fokussiere das Name-Feld, damit der Benutzer den Namen direkt √§ndern kann
        setTimeout(() => {
            const nameField = document.getElementById('bundleName');
            if (nameField) {
                nameField.focus();
                nameField.select(); // Markiere den Text, damit er direkt √ºberschrieben werden kann
            }
        }, 100);
    }
    
    function deletePattern(i) {
        // Pr√ºfe ob es Standard-Muster sind
        if (isDefaultPatternList) {
            if (!confirm('Dies ist ein Standard-Muster. M√∂chten Sie es wirklich l√∂schen?\n\nHinweis: Das Muster wird nur in der aktuellen Sitzung gel√∂scht und wird beim Neuladen wieder erscheinen.')) {
                return;
            }
        } else {
            if (!confirm("Muster wirklich l√∂schen?")) {
                return;
            }
        }
        
        patternBundles.splice(i, 1);
        updatePatternList();
    }
    
    function exportPatterns() {
        // Exportiere nur neue/importierte Muster, nicht die Standard-Muster
        if (patternBundles.length === 0) {
            alert("Keine Muster zum Exportieren vorhanden!\n\nHinweis: Standard-Muster werden nicht exportiert.");
            return;
        }
        
        // Frage den Benutzer nach dem Dateinamen
        let fileName = patternListName || 'uwe-muster';
        const userInput = prompt("Bitte geben Sie den Dateinamen ein (ohne .json):", fileName);
        
        if (userInput === null) {
            // Benutzer hat Abbrechen gedr√ºckt
            return;
        }
        
        fileName = userInput.trim();
        if (!fileName) {
            alert("Bitte geben Sie einen g√ºltigen Dateinamen ein!");
            return;
        }
        
        // Speichere den Dateinamen als Muster-Listen-Namen
        patternListName = fileName;
        updatePatternListTitle();
        
        try {
            const dataStr = JSON.stringify({ 
                patterns: patternBundles, // Nur neue Muster
                groups: patternGroups, // Nur neue Gruppen
                listName: patternListName 
            }, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName + '.json';
            a.click();
            URL.revokeObjectURL(url);
        } catch (e) {
            alert("Fehler beim Exportieren: " + e.message);
        }
    }
    
    // Funktion zum Laden von Muster-Daten (wird sowohl f√ºr Import als auch f√ºr Standard-Muster verwendet)
    function loadPatternData(data, fileName) {
        if (data.patterns && Array.isArray(data.patterns)) {
            // Pr√ºfe ob es Standard-Muster sind
            const isDefault = (fileName && fileName.toLowerCase() === 'default-patterns.json');
            
            if (isDefault) {
                // Lade in Standard-Muster-Array
                defaultPatternBundles = data.patterns;
                
                // Lade Gruppen, falls vorhanden
                if (data.groups && Array.isArray(data.groups)) {
                    defaultPatternGroups = data.groups;
                } else {
                    // Fallback: Erstelle Standard-Gruppe f√ºr alle Muster ohne Gruppe
                    const defaultGroupId = 'group_default_' + Date.now();
                    defaultPatternGroups = [{ id: defaultGroupId, name: 'Standard', collapsed: true }];
                    defaultPatternBundles.forEach(p => {
                        if (!p.groupId) p.groupId = defaultGroupId;
                    });
                }
                
                // Alle Standard-Gruppen beim Start zugeklappt
                defaultPatternGroups.forEach(g => {
                    collapsedGroups[g.id] = true;
                });
                
                isDefaultPatternList = true;
            } else {
                // Lade in neue Muster-Array
                patternBundles = data.patterns;
                
                // Lade Gruppen, falls vorhanden
                if (data.groups && Array.isArray(data.groups)) {
                    patternGroups = data.groups;
                } else {
                    // Fallback: Erstelle Standard-Gruppe f√ºr alle Muster ohne Gruppe
                    const defaultGroupId = 'group_' + Date.now();
                    // Extrahiere den Dateinamen (ohne .json) und verwende ihn als Muster-Listen-Namen
                    const cleanFileName = fileName.replace(/\.json$/i, '');
                    patternListName = data.listName || cleanFileName;
                    // Verwende den Namen des importierten Musters als Gruppennamen
                    const groupName = patternListName || 'Neues Muster';
                    patternGroups = [{ id: defaultGroupId, name: groupName, collapsed: false }];
                    patternBundles.forEach(p => {
                        if (!p.groupId) p.groupId = defaultGroupId;
                    });
                }
                
                // Extrahiere den Dateinamen (ohne .json) und verwende ihn als Muster-Listen-Namen (falls noch nicht gesetzt)
                if (!patternListName) {
                    const cleanFileName = fileName.replace(/\.json$/i, '');
                    patternListName = data.listName || cleanFileName;
                }
                
                isDefaultPatternList = false;
            }
            
            updatePatternListTitle();
            updatePatternList();
            return true;
        }
        return false;
    }
    
    function importPatterns(event) {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onerror = () => alert("Fehler beim Laden der Datei!");
        reader.onload = (f) => {
            try {
                const data = JSON.parse(f.target.result);
                if (loadPatternData(data, file.name)) {
                    // Importierte Muster sind keine Standard-Muster (au√üer es ist default-patterns.json)
                    // isDefaultPatternList wird bereits in loadPatternData gesetzt
                    alert(`${data.patterns.length} Muster in ${patternGroups.length} Gruppe(n) erfolgreich importiert!`);
                } else {
                    alert("Ung√ºltiges Dateiformat!");
                }
            } catch (e) {
                alert("Fehler beim Lesen der Datei: " + e.message);
            }
        };
        reader.readAsText(file);
        event.target.value = ''; // Reset input
    }
    
    // Lade Standard-Muster beim Programmstart
    function loadDefaultPatterns() {
        fetch('default-patterns.json')
            .then(response => {
                if (!response.ok) {
                    // Wenn die Datei nicht gefunden wird, ist das ok - dann werden keine Standard-Muster geladen
                    console.log('Standard-Muster-Datei nicht gefunden. Keine Standard-Muster werden geladen.');
                    return null;
                }
                return response.json();
            })
            .then(data => {
                if (data) {
                    loadPatternData(data, 'default-patterns.json');
                    console.log('Standard-Muster erfolgreich geladen:', data.patterns.length, 'Muster in', data.groups ? data.groups.length : 1, 'Gruppe(n)');
                }
            })
            .catch(error => {
                // Fehler beim Laden ist ok - dann werden keine Standard-Muster geladen
                console.log('Standard-Muster konnten nicht geladen werden:', error.message);
            });
    }
    
    function updatePatternListTitle() {
        const titleElement = document.getElementById('patternListTitle');
        if (patternListName) {
            titleElement.textContent = 'Muster-Liste: ' + patternListName;
        } else {
            titleElement.textContent = 'Muster-Liste';
        }
    }
    
    // Initialisiere Muster-Liste beim Start
    // Muster-Verwaltung beim Start zugeklappt
    patternManagementCollapsed = true;
    
    // Lade zuerst Standard-Muster, dann erstelle Standard-Gruppe falls n√∂tig
    loadDefaultPatterns();
    
    // Erstelle Standard-Gruppe, falls keine vorhanden (nach dem Laden der Standard-Muster)
    setTimeout(() => {
        if (patternGroups.length === 0) {
            const defaultGroupId = 'group_' + Date.now();
            patternGroups.push({ id: defaultGroupId, name: 'Neues Muster', collapsed: false });
        }
        updatePatternListTitle();
        updatePatternList();
        
        // Stelle sicher, dass Muster-Verwaltung zugeklappt ist
        const content = document.getElementById('patternManagementContent');
        const toggle = document.getElementById('patternManagementToggle');
        if (content && toggle) {
            content.style.display = 'none';
            toggle.textContent = '‚ñ∂';
        }
    }, 100); // Kurze Verz√∂gerung, damit loadDefaultPatterns zuerst ausgef√ºhrt wird

    function autoFill(cls, inc) {
        const rows = document.querySelectorAll("#wireTable tbody tr");
        const val = rows[0].querySelector("."+cls).value;
        for(let i=1; i<rows.length; i++) {
            const f = rows[i].querySelector("."+cls);
            if(inc) {
                const m = val.match(/(\d+)$/);
                if(!m) { f.value = val; continue; }
                f.value = val.substring(0, val.length-m[1].length) + (parseInt(m[1])+i).toString().padStart(m[1].length, '0');
            } else f.value = val;
        }
    }

    function saveProjectJSON() {
        if (allBundles.length === 0 && !originalImageSnapshot) {
            alert("Keine Daten zum Speichern vorhanden!");
            return;
        }
        const defaultName = "UWE_Projekt_" + new Date().toISOString().split('T')[0];
        const fileName = prompt("Dateiname eingeben:", defaultName);
        if (fileName === null) return; // Abbrechen
        
        const projectData = { 
            version: "1.0",
            mmPerPixel, 
            realLengthValue: document.getElementById('realLength').value, 
            bundles: allBundles,
            imageData: img.src && img.src.startsWith('data:') ? img.src : null,
            exportDate: new Date().toISOString()
        };
        try {
            const blob = new Blob([JSON.stringify(projectData, null, 2)], { type: 'application/json' });
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
            a.download = (fileName.trim() || defaultName) + ".json";
        a.click();
            URL.revokeObjectURL(a.href);
        } catch(err) {
            alert("Fehler beim Speichern: " + err.message);
        }
    }

    function loadProjectJSON(event) {
        if (!event.target.files || !event.target.files[0]) return;
        const reader = new FileReader();
        reader.onerror = () => alert("Fehler beim Laden der Datei!");
        reader.onload = (e) => {
            try {
            const data = JSON.parse(e.target.result);
                allBundles = data.bundles || [];
                mmPerPixel = data.mmPerPixel || 0;
                document.getElementById('realLength').value = data.realLengthValue || 0;
            document.getElementById('btnMeasure').disabled = false;
                
                // Bild laden falls vorhanden
                if (data.imageData) {
                    img.onload = () => {
                        if (autoFitToWindow) {
                            resizeCanvas();
                        } else {
                            canvas.width = img.width; 
                            canvas.height = img.height;
                            imageScale = 1;
                            imageOffsetX = 0;
                            imageOffsetY = 0;
                        }
                        // Reset Zoom und Pan beim Laden eines Projekts
                        zoom = 1;
                        panX = 0;
                        panY = 0;
                        originalImageSnapshot = ctx.getImageData(0,0,canvas.width, canvas.height);
            rebuildDrawing();
                    };
                    img.onerror = () => alert("Fehler beim Laden des Bildes!");
                    img.src = data.imageData;
                }
                
                updateSidebarList();
                if(originalImageSnapshot) rebuildDrawing();
            } catch(err) {
                alert("Fehler: Ung√ºltige Projektdatei! " + err.message);
            }
        };
        reader.readAsText(event.target.files[0]);
    }

    function exportWustec() {
        if (allBundles.length === 0) {
            alert("Keine Kabelstr√§nge vorhanden!");
            return;
        }
        let csv = "ID;Quelle;Ziel;Querschnitt;Farbe;L√§nge_mm;Drucktext_Quelle;Drucktext_Ziel;Ader-Typ;Crimpung_Quelle;Crimpung_Ziel;Reserve_mm;BMK_Quelle;BMK_Ziel\n";
        allBundles.forEach((b, bi) => {
            if (!b.wires || b.wires.length === 0) return;
            b.wires.forEach((w, wi) => {
            const len = Math.round(b.len+b.pS+b.pE);
                csv += `${bi+1}_${wi+1};${w.s || ''};${b.name || ''};${w.cr || ''};${w.c || ''};${len};${w.s || ''};${w.e || ''};${w.t || ''};Aderendh√ºlse;Aderendh√ºlse;0;${b.name || ''};${b.name || ''}\n`;
            });
        });
        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const a = document.createElement("a"); 
        a.href = URL.createObjectURL(blob); 
        a.download = "Wustec_Export_" + new Date().toISOString().split('T')[0] + ".csv"; 
        a.click();
        URL.revokeObjectURL(a.href);
    }

    function exportVisual() {
        if (!img.complete || img.width === 0 || allBundles.length === 0) {
            alert("Keine Daten zum Exportieren vorhanden!");
            return;
        }
        
        // Pr√ºfe ob jsPDF verf√ºgbar ist
        if (typeof window.jspdf === 'undefined') {
            alert("PDF-Bibliothek konnte nicht geladen werden. Bitte laden Sie die Seite neu.");
            return;
        }
        
        const { jsPDF } = window.jspdf;
        
        // Erstelle ein tempor√§res Canvas mit Original-Bildgr√∂√üe (ohne autoFitToWindow)
        const imageCanvas = document.createElement('canvas');
        imageCanvas.width = img.width;
        imageCanvas.height = img.height;
        const imgCtx = imageCanvas.getContext('2d');
        
        // Zeichne das Bild in Originalgr√∂√üe
        imgCtx.drawImage(img, 0, 0);
        
        // Zeichne alle Str√§nge in Original-Bildkoordinaten (ohne Transformationen)
        allBundles.forEach(b => {
            if (!b.path || b.path.length === 0) return;
            imgCtx.strokeStyle = b.color;
            imgCtx.lineWidth = Math.max(4, img.width / 500);
            imgCtx.beginPath();
            imgCtx.moveTo(b.path[0].x, b.path[0].y);
            b.path.forEach(p => imgCtx.lineTo(p.x, p.y));
            imgCtx.stroke();
        });
        
        // Erstelle PDF im A4 Format (210mm x 297mm)
        const pdf = new jsPDF({
            orientation: 'portrait',
            unit: 'mm',
            format: 'a4'
        });
        
        // Berechne die maximale Gr√∂√üe f√ºr das Bild auf A4 (mit R√§ndern)
        const pageWidth = 210; // A4 Breite in mm
        const pageHeight = 297; // A4 H√∂he in mm
        const margin = 15; // Rand in mm
        const maxWidth = pageWidth - (2 * margin);
        const maxHeight = pageHeight - (2 * margin);
        
        // Berechne Skalierung, damit das Bild auf die Seite passt
        const imgAspectRatio = img.width / img.height;
        let imgWidth = maxWidth;
        let imgHeight = imgWidth / imgAspectRatio;
        
        if (imgHeight > maxHeight) {
            imgHeight = maxHeight;
            imgWidth = imgHeight * imgAspectRatio;
        }
        
        // Zentriere das Bild auf der Seite
        const xPos = (pageWidth - imgWidth) / 2;
        const yPos = margin;
        
        // Seite 1: Bild
        const imgData = imageCanvas.toDataURL('image/png');
        pdf.addImage(imgData, 'PNG', xPos, yPos, imgWidth, imgHeight);
        pdf.addPage();
        
        // Seite 2: Legende
        pdf.setFontSize(20);
        pdf.setFont(undefined, 'bold');
        pdf.text('Legende Kabelstr√§nge (UWE)', margin, margin + 10);
        
        pdf.setFontSize(12);
        pdf.setFont(undefined, 'normal');
        
        let yPosLegend = margin + 25;
        const lineHeight = 8;
        const maxY = pageHeight - margin;
        
        // Funktion zum Gruppieren von Adern nach Farbe und Querschnitt
        function getWireSpecification(wires) {
            if (!wires || wires.length === 0) return '';
            
            // Mapping von Farb-Codes zu lesbaren Namen
            const colorMap = {
                'bk': 'sw',      // Schwarz
                'bl': 'bl',      // Blau
                'br': 'br',      // Braun
                'gnge': 'gnge',  // Gr√ºn-Gelb
                'rt': 'rt',      // Rot
                'gr': 'gr',      // Grau
                'or': 'or',      // Orange
                'ws': 'ws',      // Wei√ü
                'wsbk': 'wsbk',  // Wei√ü-Schwarz
                'dbl': 'dbl',    // Dunkelblau
                'dblws': 'dblws' // Dunkelblau-Wei√ü
            };
            
            // Gruppiere Adern nach Farbe und Querschnitt
            const groups = {};
            wires.forEach(wire => {
                const colorCode = wire.c || 'unbekannt';
                const colorName = colorMap[colorCode] || colorCode;
                const cross = wire.cr || '0';
                const key = `${colorCode}_${cross}`;
                
                if (!groups[key]) {
                    groups[key] = {
                        colorName: colorName,
                        cross: cross,
                        count: 0
                    };
                }
                groups[key].count++;
            });
            
            // Erstelle Format-String: "5x sw = 2,5mmq ; 1x bl = 2,5mmq"
            const parts = [];
            Object.values(groups).forEach(group => {
                const crossFormatted = group.cross.replace('.', ',');
                parts.push(`${group.count}x ${group.colorName} = ${crossFormatted}mmq`);
            });
            
            return parts.join(' ; ');
        }
        
        allBundles.forEach((b, i) => {
            // Pr√ºfe ob noch Platz auf der Seite ist
            if (yPosLegend > maxY - lineHeight) {
                pdf.addPage();
                yPosLegend = margin + 10;
            }
            
            // Zeichne Farbkreis (als Rechteck, da jsPDF keine Kreise direkt unterst√ºtzt)
            pdf.setFillColor(b.color || '#000000');
            pdf.circle(margin + 5, yPosLegend - 2, 3, 'F');
            
            // Text
            const wireCount = b.wires ? b.wires.length : 0;
            const totalLength = Math.round((b.len || 0) + (b.pS || 0) + (b.pE || 0));
            const wireSpec = getWireSpecification(b.wires);
            const legendText = `${b.name || 'Unbenannt'}: ${wireCount} Ader${wireCount !== 1 ? 'n' : ''}, ca. ${totalLength}mm${wireSpec ? ', ' + wireSpec : ''}`;
            pdf.text(legendText, margin + 12, yPosLegend);
            
            yPosLegend += lineHeight + 2;
        });
        
        // Speichere PDF
        const fileName = "UWE_Doku_" + new Date().toISOString().split('T')[0] + ".pdf";
        pdf.save(fileName);
    }
    
    // ========== Hilfe/Anleitung Funktionen ==========
    
    function openHelpWindow() {
        const helpWindow = window.open('', 'UWE_Anleitung', 'width=800,height=700,scrollbars=yes,resizable=yes');
        if (!helpWindow) {
            alert('Bitte erlauben Sie Popups f√ºr diese Seite, um die Anleitung zu √∂ffnen.');
            return;
        }
        
        helpWindow.document.write(`
            <!DOCTYPE html>
            <html lang="de">
            <head>
                <meta charset="UTF-8">
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <title>UWE - Anleitung</title>
                <style>
                    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
                    * { box-sizing: border-box; margin: 0; padding: 0; }
                    body {
                        font-family: 'Inter', sans-serif;
                        background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
                        color: white;
                        padding: 30px;
                        line-height: 1.6;
                    }
                    .container {
                        max-width: 750px;
                        margin: 0 auto;
                        background: rgba(30, 41, 59, 0.9);
                        padding: 30px;
                        border-radius: 12px;
                        box-shadow: 0 8px 32px rgba(0,0,0,0.3);
                    }
                    h1 {
                        color: #6366f1;
                        margin-bottom: 10px;
                        font-size: 2em;
                        border-bottom: 2px solid rgba(99, 102, 241, 0.3);
                        padding-bottom: 10px;
                    }
                    h2 {
                        color: #8b5cf6;
                        margin-top: 25px;
                        margin-bottom: 15px;
                        font-size: 1.4em;
                    }
                    h3 {
                        color: #a78bfa;
                        margin-top: 20px;
                        margin-bottom: 10px;
                        font-size: 1.2em;
                    }
                    p {
                        margin-bottom: 12px;
                    }
                    ul, ol {
                        margin-left: 25px;
                        margin-bottom: 15px;
                    }
                    li {
                        margin-bottom: 8px;
                    }
                    .section {
                        margin-bottom: 30px;
                        padding: 20px;
                        background: rgba(255,255,255,0.05);
                        border-radius: 8px;
                        border-left: 4px solid #6366f1;
                    }
                    .highlight {
                        background: rgba(99, 102, 241, 0.2);
                        padding: 2px 6px;
                        border-radius: 4px;
                        font-weight: 600;
                    }
                    code {
                        background: rgba(0,0,0,0.3);
                        padding: 2px 6px;
                        border-radius: 4px;
                        font-family: 'Courier New', monospace;
                        font-size: 0.9em;
                    }
                    .tip {
                        background: rgba(16, 185, 129, 0.2);
                        border-left: 4px solid #10b981;
                        padding: 12px;
                        margin: 15px 0;
                        border-radius: 4px;
                    }
                    .warning {
                        background: rgba(239, 68, 68, 0.2);
                        border-left: 4px solid #ef4444;
                        padding: 12px;
                        margin: 15px 0;
                        border-radius: 4px;
                    }
                </style>
            </head>
            <body>
                <div class="container">
                    <h1>üìò UWE - Universal Wiring Engine</h1>
                    <p><strong>Anleitung zur Verwendung der Anwendung</strong></p>
                    
                    <div class="section">
                        <h2>1. Die Ribbon-Bar</h2>
                        <p>Die Ribbon-Bar befindet sich oben im Programmfenster und ist in folgende Bereiche unterteilt:</p>
                        <ol>
                            <li><strong>Bild:</strong> Laden Sie ein Bild, auf dem Sie die Kabelstr√§nge zeichnen m√∂chten</li>
                            <li><strong>Ma√üstab:</strong> Legen Sie den Ma√üstab fest, um pr√§zise L√§ngenmessungen durchzuf√ºhren</li>
                            <li><strong>Datei:</strong> Speichern Sie Ihr Projekt oder laden Sie ein gespeichertes Projekt</li>
                            <li><strong>Export:</strong> Exportieren Sie die Daten als Wustec CSV-Datei oder als Bild & Legende PDF</li>
                            <li><strong>Muster:</strong> Verwalten Sie Muster-Kabelstr√§nge - exportieren oder importieren Sie Muster-Sammlungen</li>
                        </ol>
                        <p><em>Hinweis: Die "Muster"-Gruppe befindet sich rechts neben dem HUNDT-Logo.</em></p>
                    </div>
                    
                    <div class="section">
                        <h2>2. Grundlagen</h2>
                        <p>UWE ist eine professionelle Anwendung zur Erfassung und Dokumentation von Kabelb√§umen mit Ma√üstab-Messung und verschiedenen Export-Funktionen.</p>
                        
                        <h3>2.1 Bild laden</h3>
                        <ol>
                            <li>Klicken Sie auf <span class="highlight">"Bild ausw√§hlen"</span> im ersten Schritt</li>
                            <li>W√§hlen Sie eine Bilddatei von Ihrem Computer</li>
                            <li>Das Bild wird automatisch geladen und angezeigt</li>
                        </ol>
                        
                        <h3>2.2 Ma√üstab festlegen</h3>
                        <ol>
                            <li>Messen Sie eine bekannte L√§nge im Bild (z.B. mit einem Lineal am Bildschirm)</li>
                            <li>Geben Sie die L√§nge in <span class="highlight">Millimetern (mm)</span> ein</li>
                            <li>Klicken Sie auf <span class="highlight">"Ma√üstab festlegen"</span></li>
                            <li>Zeichnen Sie eine Linie im Bild √ºber die gemessene Strecke</li>
                            <li>Best√§tigen Sie mit <span class="highlight">"Ma√üstab best√§tigen ‚úì"</span></li>
                        </ol>
                        <div class="tip">
                            üí° <strong>Tipp:</strong> Je l√§nger die Referenzstrecke, desto genauer wird der Ma√üstab!
                        </div>
                    </div>
                    
                    <div class="section">
                        <h2>3. Kabelstr√§nge zeichnen</h2>
                        <h3>3.1 Kabelstrang erstellen</h3>
                        <ol>
                            <li>W√§hlen Sie eine <span class="highlight">Farbe</span> f√ºr den Kabelstrang</li>
                            <li>Klicken Sie auf <span class="highlight">"Kabelstrang zeichnen"</span></li>
                            <li>Klicken Sie mit der Maus im Bild, um Punkte zu setzen</li>
                            <li><strong>Doppelklick</strong> beendet das Zeichnen</li>
                            <li>Geben Sie im ge√∂ffneten Dialog den <span class="highlight">Namen</span> ein</li>
                            <li>F√ºgen Sie <span class="highlight">Zuschl√§ge</span> (Vorn/Hinten in mm) hinzu</li>
                            <li>Definieren Sie die <span class="highlight">Adern</span> mit Typ, Farbe, Querschnitt (mm¬≤) und Bezeichnungen</li>
                            <li>Klicken Sie auf <span class="highlight">"Speichern"</span></li>
                        </ol>
                        <div class="tip">
                            üí° <strong>Tipp:</strong> Doppelklick beendet das Zeichnen eines Kabelstrangs automatisch!
                        </div>
                        
                        <h3>3.2 Kabelstrang bearbeiten</h3>
                        <ul>
                            <li>Klicken Sie auf <span class="highlight">‚úé</span> (Bearbeiten) in der Kabelstrang-Liste</li>
                            <li>√Ñndern Sie die gew√ºnschten Werte</li>
                            <li>Speichern Sie die √Ñnderungen</li>
                        </ul>
                        
                        <h3>3.3 Kabelstrang neu zeichnen</h3>
                        <ul>
                            <li>Klicken Sie auf <span class="highlight">‚Üª</span> (Neu zeichnen)</li>
                            <li>Zeichnen Sie einen neuen Pfad</li>
                            <li>Alle anderen Daten (Name, Adern, etc.) bleiben erhalten</li>
                        </ul>
                        
                        <h3>3.4 Kabelstrang duplizieren</h3>
                        <ul>
                            <li>Klicken Sie auf <span class="highlight">üìã</span> (Duplizieren)</li>
                            <li>Der Kabelstrang wird kopiert und zum Bearbeiten ge√∂ffnet</li>
                            <li>√Ñndern Sie den Namen und speichern Sie</li>
                        </ul>
                        
                        <h3>3.5 Farbe √§ndern</h3>
                        <ul>
                            <li>Klicken Sie auf den <span class="highlight">Farbpunkt</span> neben dem Kabelstrang-Namen</li>
                            <li>W√§hlen Sie eine neue Farbe aus dem Farbw√§hler</li>
                        </ul>
                    </div>
                    
                    <div class="section">
                        <h2>4. Navigation im Bild</h2>
                        <h3>4.1 Zoomen</h3>
                        <ul>
                            <li>Verwenden Sie das <span class="highlight">Mausrad</span> zum Zoomen</li>
                            <li>Das Bild zoomt zum Mauszeiger hin (Zoom-Zentrum am Mauszeiger)</li>
                            <li>Zoom-Bereich: 10% bis 500%</li>
                        </ul>
                        
                        <h3>4.2 Verschieben (Panning)</h3>
                        <ul>
                            <li>Halten Sie die <span class="highlight">mittlere Maustaste</span> gedr√ºckt</li>
                            <li>Bewegen Sie die Maus, um das Bild zu verschieben</li>
                        </ul>
                        
                        <h3>4.3 Bild automatisch an Fenster anpassen</h3>
                        <ul>
                            <li>Aktivieren Sie die <span class="highlight">Checkbox "Bild wird automatisch an Fenster angepasst"</span></li>
                            <li>Das Bild wird automatisch skaliert, um optimal in das Fenster zu passen</li>
                            <li>Zum Zur√ºcksetzen die Checkbox deaktivieren</li>
                        </ul>
                    </div>
                    
                    <div class="section">
                        <h2>5. Muster-Kabelstr√§nge</h2>
                        <h3>5.1 Muster erstellen</h3>
                        <ol>
                            <li>Klicken Sie auf <span class="highlight">"+ Neues Muster"</span></li>
                            <li>Geben Sie alle Daten ein (Name, Farbe, Adern, etc.)</li>
                            <li>W√§hlen Sie eine <span class="highlight">Gruppe</span> aus oder erstellen Sie eine neue</li>
                            <li>Speichern Sie das Muster (ohne Pfad - nur Vorlage)</li>
                        </ol>
                        
                        <h3>5.2 Muster ausw√§hlen und zeichnen</h3>
                        <ol>
                            <li>Klicken Sie auf <span class="highlight">‚úì</span> (Muster ausw√§hlen) bei einem Muster</li>
                            <li>Alle Muster-Daten werden geladen</li>
                            <li>Zeichnen Sie den Pfad im Bild (wie bei normalen Kabelstr√§ngen)</li>
                            <li>Nach dem <strong>Doppelklick</strong> √∂ffnet sich das Modal mit allen Daten</li>
                            <li>Speichern Sie - der Kabelstrang wird automatisch zur Liste hinzugef√ºgt</li>
                        </ol>
                        
                        <h3>5.3 Gruppen verwalten</h3>
                        <ul>
                            <li><strong>Neue Gruppe:</strong> Klicken Sie auf <span class="highlight">"+ Neue Gruppe"</span></li>
                            <li><strong>Gruppe umbenennen:</strong> Klicken Sie auf <span class="highlight">‚úé</span> im Gruppen-Header</li>
                            <li><strong>Gruppe l√∂schen:</strong> Klicken Sie auf <span class="highlight">‚úï</span> im Gruppen-Header oder verwenden Sie den Button <span class="highlight">"Gruppe l√∂schen"</span></li>
                            <li><strong>Auf-/Zuklappen:</strong> Klicken Sie auf den Gruppen-Header (‚ñ∂ = zugeklappt, ‚ñº = aufgeklappt)</li>
                        </ul>
                        <div class="tip">
                            üí° <strong>Tipp:</strong> Gruppen werden standardm√§√üig zugeklappt, um die √úbersicht zu verbessern!
                        </div>
                        
                        <h3>5.4 Muster duplizieren</h3>
                        <ul>
                            <li>Klicken Sie auf <span class="highlight">üìã</span> (Duplizieren)</li>
                            <li>Das Muster wird kopiert und zum Bearbeiten ge√∂ffnet</li>
                            <li>√Ñndern Sie den Namen und die gew√ºnschten Daten</li>
                            <li>W√§hlen Sie eine Gruppe f√ºr das duplizierte Muster</li>
                            <li>Speichern Sie</li>
                        </ul>
                        
                        <h3>5.5 Muster exportieren/importieren</h3>
                        <ul>
                            <li><strong>Export:</strong> Klicken Sie auf <span class="highlight">"Muster exportieren"</span> - Dateiname wird abgefragt</li>
                            <li><strong>Import:</strong> Klicken Sie auf <span class="highlight">"üì• Muster importieren"</span> und w√§hlen Sie eine JSON-Datei</li>
                            <li>Muster k√∂nnen unabh√§ngig von Projekten gespeichert und geladen werden</li>
                            <li>Beim Import wird der Dateiname als Titel der Muster-Liste angezeigt</li>
                        </ul>
                    </div>
                    
                    <div class="section">
                        <h2>6. Projekt-Verwaltung</h2>
                        <h3>6.1 Projekt speichern</h3>
                        <ol>
                            <li>Klicken Sie auf <span class="highlight">"Speichern"</span> im Projekt-Speicher-Bereich</li>
                            <li>Geben Sie einen Dateinamen ein (Standard wird vorgeschlagen)</li>
                            <li>Das Projekt wird als JSON-Datei gespeichert</li>
                            <li><span class="highlight">Enth√§lt:</span> Bild, Ma√üstab, alle Kabelstr√§nge mit Pfaden und Adern</li>
                        </ol>
                        
                        <h3>6.2 Projekt laden</h3>
                        <ol>
                            <li>Klicken Sie auf <span class="highlight">"Laden"</span></li>
                            <li>W√§hlen Sie eine gespeicherte Projektdatei (JSON)</li>
                            <li>Alle Daten werden automatisch geladen</li>
                        </ol>
                        <div class="warning">
                            ‚ö†Ô∏è <strong>Hinweis:</strong> Beim Laden eines Projekts werden alle aktuellen Daten √ºberschrieben!
                        </div>
                    </div>
                    
                    <div class="section">
                        <h2>6. Export-Funktionen</h2>
                        <h3>6.1 Wustec Export (CSV)</h3>
                        <ul>
                            <li>Klicken Sie auf <span class="highlight">"Wustec Export (.csv)"</span></li>
                            <li>Eine CSV-Datei wird heruntergeladen</li>
                            <li>Enth√§lt alle Kabelstr√§nge mit Adern-Details</li>
                            <li>Kompatibel mit Wustec-Software</li>
                        </ul>
                        
                        <h3>6.2 Bild & Legende Export</h3>
                        <ul>
                            <li>Klicken Sie auf <span class="highlight">"Bild & Legende Export"</span></li>
                            <li>Ein kombiniertes Bild wird erstellt</li>
                            <li>Bild wird immer in <strong>Originalgr√∂√üe</strong> exportiert (unabh√§ngig von Zoom/Einstellungen)</li>
                            <li>Legende wird rechts neben dem Bild angezeigt</li>
                            <li>Dateiname enth√§lt automatisch das Datum</li>
                        </ul>
                    </div>
                    
                    <div class="section">
                        <h2>7. Tastenk√ºrzel & Interaktionen</h2>
                        <ul>
                            <li><strong>Mausrad:</strong> Zoomen (zoomt zum Mauszeiger hin)</li>
                            <li><strong>Mittlere Maustaste:</strong> Bild verschieben (Panning)</li>
                            <li><strong>Doppelklick:</strong> Zeichnen beenden</li>
                            <li><strong>Farbpunkt klicken:</strong> Farbe √§ndern</li>
                            <li><strong>Button-Hover:</strong> Tooltips mit Beschreibungen anzeigen</li>
                        </ul>
                    </div>
                    
                    <div class="section">
                        <h2>8. Unterst√ºtzte Adern-Farben</h2>
                        <p>Folgende Farben stehen zur Verf√ºgung:</p>
                        <ul>
                            <li>Schwarz (bk), Blau (bl), Dunkelblau (dbl), Dunkelblau-Wei√ü (dblws)</li>
                            <li>Braun (br), Gr√ºn-Gelb (gnge), Rot (rt)</li>
                            <li>Grau (gr), Orange (or), Wei√ü (ws)</li>
                        </ul>
                    </div>
                    
                    <div class="section">
                        <h2>9. Tipps & Best Practices</h2>
                        <ul>
                            <li>Speichern Sie regelm√§√üig Ihre Projekte</li>
                            <li>Verwenden Sie aussagekr√§ftige Namen f√ºr Kabelstr√§nge</li>
                            <li>Organisieren Sie Muster in Gruppen f√ºr bessere √úbersicht</li>
                            <li>Pr√ºfen Sie den Ma√üstab vor dem Zeichnen</li>
                            <li>Bei gro√üen Bildern: Nutzen Sie Zoom und Panning</li>
                            <li>Exportieren Sie Muster f√ºr Wiederverwendung in anderen Projekten</li>
                        </ul>
                    </div>
                </div>
            </body>
            </html>
        `);
        
        helpWindow.document.close();
    }
</script>
</body>
</html>